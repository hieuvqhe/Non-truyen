This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/copilot-intructions.md
.gitignore
components.json
eslint.config.js
index.html
package.json
public/vite.svg
README.md
src/apis/category.api.ts
src/apis/comic.api.ts
src/App.css
src/App.tsx
src/assets/react.svg
src/components/Carousel.tsx
src/components/CarouselItem.tsx
src/components/CircularGallery.tsx
src/components/layout/Footer.tsx
src/components/layout/Header.tsx
src/components/layout/MainLayout.tsx
src/components/mode-toggle.tsx
src/components/SpotlightCard.tsx
src/components/theme-provider.tsx
src/components/TiltedCard.tsx
src/components/ui/avatar.tsx
src/components/ui/button.tsx
src/components/ui/dropdown-menu.tsx
src/components/ui/input.tsx
src/components/ui/sonner.tsx
src/constants/config.ts
src/constants/path.ts
src/hooks/useDebounce.ts
src/index.css
src/lib/utils.ts
src/main.tsx
src/pages/Category/CategoryPage.tsx
src/pages/Category/index.ts
src/pages/ChapterDetail/ChapterDetail.tsx
src/pages/ChapterDetail/index.ts
src/pages/ComicDetail/ComicDetail.tsx
src/pages/ComicDetail/index.ts
src/pages/HomePage/HomePage.tsx
src/pages/HomePage/index.tsx
src/pages/NewComic/index.tsx
src/pages/NewComic/NewComic.tsx
src/pages/SearchPage/index.ts
src/pages/SearchPage/SearchPage.tsx
src/store/authStore.ts
src/store/comicStore.ts
src/types/Category.type.ts
src/types/Comic.type.ts
src/types/User.type.ts
src/types/Utils.type.ts
src/utils/auth.ts
src/utils/http.ts
src/vite-env.d.ts
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/copilot-intructions.md">
You are a Senior Front-End Developer and an Expert in ReactJS, NextJS, JavaScript, TypeScript, HTML, CSS and modern UI/UX frameworks (e.g., TailwindCSS, Shadcn, Radix). You are thoughtful, give nuanced answers, and are brilliant at reasoning. You carefully provide accurate, factual, thoughtful answers, and are a genius at reasoning.

- Follow the user’s requirements carefully & to the letter.
- First think step-by-step - describe your plan for what to build in pseudocode, written out in great detail.
- Confirm, then write code!
- Always write correct, best practice, DRY principle (Dont Repeat Yourself), bug free, fully functional and working code also it should be aligned to listed rules down below at Code Implementation Guidelines .
- Focus on easy and readability code, over being performant.
- Fully implement all requested functionality.
- Leave NO todo’s, placeholders or missing pieces.
- Ensure code is complete! Verify thoroughly finalised.
- Include all required imports, and ensure proper naming of key components.
- Be concise Minimize any other prose.
- If you think there might not be a correct answer, you say so.
- If you do not know the answer, say so, instead of guessing.

### Coding Environment
The user asks questions about the following coding languages:
- ReactJS
- NextJS
- JavaScript
- TypeScript
- TailwindCSS
- HTML
- CSS

### Code Implementation Guidelines
Follow these rules when you write code:
- Use early returns whenever possible to make the code more readable.
- Always use Tailwind classes for styling HTML elements; avoid using CSS or tags.
- Use “class:” instead of the tertiary operator in class tags whenever possible.
- Use descriptive variable and function/const names. Also, event functions should be named with a “handle” prefix, like “handleClick” for onClick and “handleKeyDown” for onKeyDown.
- Implement accessibility features on elements. For example, a tag should have a tabindex=“0”, aria-label, on:click, and on:keydown, and similar attributes.
- Use consts instead of functions, for example, “const toggle = () =>”. Also, define a type if possible.
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/App.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body class="theme-initialized">
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "non-truyen",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-slot": "^1.1.2",
    "@tailwindcss/vite": "^4.0.17",
    "axios": "^1.8.4",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "framer-motion": "^12.6.2",
    "lucide-react": "^0.484.0",
    "next-themes": "^0.4.6",
    "ogl": "^1.0.11",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-router-dom": "^7.4.0",
    "sonner": "^2.0.2",
    "tailwind-merge": "^3.0.2",
    "tailwindcss": "^4.0.17",
    "tw-animate-css": "^1.2.4",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@eslint/js": "^9.21.0",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react-swc": "^3.8.0",
    "eslint": "^9.21.0",
    "eslint-plugin-react-hooks": "^5.1.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^15.15.0",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.24.1",
    "vite": "^6.2.0"
  }
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```
</file>

<file path="src/apis/category.api.ts">
import { Category, CategoryApiResponse } from '../types/Category.type'
import http from '../utils/http'

/**
 * API functions for interacting with category endpoints
 */
const categoryApi = {
  /**
   * Fetches all categories from the API
   * @returns Promise with category data
   */
  getAll: () => {
    return http.get<CategoryApiResponse>('/the-loai').then((response) => ({
      data: {
        items: response.data.data.items.map((item) => ({
          _id: item._id,
          name: item.name,
          slug: item.slug
        })) as Category[]
      }
    }))
  }
}

export default categoryApi
</file>

<file path="src/App.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));
#root {
  max-width: 1280px;
  margin: 0 auto;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="src/App.tsx">
import MainLayout from "./components/layout/MainLayout"
import { ThemeProvider } from "./components/theme-provider"
import { Toaster } from "./components/ui/sonner"
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom'
import path from "./constants/path"
import HomePage from "./pages/HomePage"
import ComicDetail from "./pages/ComicDetail"
import ChapterDetail from "./pages/ChapterDetail"
import CategoryPage from "./pages/Category/CategoryPage" 
import SearchPage from "./pages/SearchPage/SearchPage" // Import SearchPage

function App() {
  return (
    <Router>
      <ThemeProvider defaultTheme="dark" storageKey="vite-ui-theme">
        <div className="container mx-auto">
          <Toaster />
          <MainLayout>
            <Routes>
              <Route path={path.home} element={<HomePage />} />
              <Route path="/the-loai/:slug" element={<CategoryPage />} /> 
              <Route path="/truyen-tranh/:slug" element={<ComicDetail />} />
              <Route path="/truyen-tranh/:slug/chapter/:chapterName" element={<ChapterDetail />} />
              <Route path="/search" element={<SearchPage />} /> {/* Add search route */}
            </Routes>
          </MainLayout>
        </div>
      </ThemeProvider>
    </Router>
  )
}

export default App
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/Carousel.tsx">
import { useEffect, useState, useRef } from "react";
import { motion, useMotionValue } from "framer-motion";
import useComicStore from "../store/comicStore";
import CarouselItem from "./CarouselItem";

const DRAG_BUFFER = 0;
const VELOCITY_THRESHOLD = 500;
const GAP = 16;
const SPRING_OPTIONS = { type: "spring", stiffness: 300, damping: 30 };

export default function Carousel({
  baseWidth = 300,
  autoplay = false,
  autoplayDelay = 3000,
  pauseOnHover = false,
  loop = false,
  round = false,
}) {
  const { homeComics, isLoadingHomeComics, fetchHomeComics } = useComicStore();
  
  // Fetch comics when component mounts
  useEffect(() => {
    fetchHomeComics();
  }, [fetchHomeComics]);
  
  const containerPadding = 16;
  const itemWidth = baseWidth - containerPadding * 2;
  const trackItemOffset = itemWidth + GAP;

  // Use homeComics if available, otherwise use an empty array
  const items = homeComics.length > 0 ? homeComics.slice(0, 10) : [];
  const carouselItems = loop ? [...items, items[0]] : items;
  
  const [currentIndex, setCurrentIndex] = useState(0);
  const x = useMotionValue(0);
  const [isHovered, setIsHovered] = useState(false);
  const [isResetting, setIsResetting] = useState(false);

  const containerRef = useRef<HTMLDivElement>(null);
  useEffect(() => {
    if (pauseOnHover && containerRef.current) {
      const container = containerRef.current;
      const handleMouseEnter = () => setIsHovered(true);
      const handleMouseLeave = () => setIsHovered(false);
      container.addEventListener("mouseenter", handleMouseEnter);
      container.addEventListener("mouseleave", handleMouseLeave);
      return () => {
        container.removeEventListener("mouseenter", handleMouseEnter);
        container.removeEventListener("mouseleave", handleMouseLeave);
      };
    }
  }, [pauseOnHover]);

  useEffect(() => {
    if (autoplay && (!pauseOnHover || !isHovered)) {
      const timer = setInterval(() => {
        setCurrentIndex((prev) => {
          if (prev === items.length - 1 && loop) {
            return prev + 1; // Animate to clone.
          }
          if (prev === carouselItems.length - 1) {
            return loop ? 0 : prev;
          }
          return prev + 1;
        });
      }, autoplayDelay);
      return () => clearInterval(timer);
    }
  }, [
    autoplay,
    autoplayDelay,
    isHovered,
    loop,
    items.length,
    carouselItems.length,
    pauseOnHover,
  ]);

  const effectiveTransition = isResetting ? { duration: 0 } : SPRING_OPTIONS;

  const handleAnimationComplete = () => {
    if (loop && currentIndex === carouselItems.length - 1) {
      setIsResetting(true);
      x.set(0);
      setCurrentIndex(0);
      setTimeout(() => setIsResetting(false), 50);
    }
  };

  // Define the PanInfo interface for drag events
  interface PanInfo {
    offset: {
        x: number;
        y: number;
    };
    velocity: {
        x: number;
        y: number;
    };
  }

  const handleDragEnd = (_: any, info: PanInfo) => {
    const offset = info.offset.x;
    const velocity = info.velocity.x;
    if (offset < -DRAG_BUFFER || velocity < -VELOCITY_THRESHOLD) {
        if (loop && currentIndex === items.length - 1) {
            setCurrentIndex(currentIndex + 1);
        } else {
            setCurrentIndex((prev) => Math.min(prev + 1, carouselItems.length - 1));
        }
    } else if (offset > DRAG_BUFFER || velocity > VELOCITY_THRESHOLD) {
        if (loop && currentIndex === 0) {
            setCurrentIndex(items.length - 1);
        } else {
            setCurrentIndex((prev) => Math.max(prev - 1, 0));
        }
    }
  };

  const dragProps = loop
    ? {}
    : {
      dragConstraints: {
        left: -trackItemOffset * (carouselItems.length - 1),
        right: 0,
      },
    };

  // If still loading, show a loading indicator
  if (isLoadingHomeComics) {
    return (
      <div 
        className="flex items-center justify-center rounded-[16px] bg-card"
        style={{
          width: `${baseWidth}px`,
          height: "400px",
          maxWidth: '100%',
        }}
      >
        <div className="text-card-foreground">Loading comics...</div>
      </div>
    );
  }

  return (
    <div
      ref={containerRef}
      className={`relative overflow-hidden p-4 ${round
        ? "rounded-full"
        : "rounded-[16px]"
        }`}
      style={{
        width: `${baseWidth}px`,
        maxWidth: '100%',
        ...(round && { height: `${baseWidth}px` }),
      }}
    >
      <motion.div
        className="flex"
        drag="x"
        {...dragProps}
        style={{
          width: itemWidth,
          gap: `${GAP}px`,
          perspective: 1000,
          perspectiveOrigin: `${currentIndex * trackItemOffset + itemWidth / 2}px 50%`,
          x,
        }}
        onDragEnd={handleDragEnd}
        animate={{ x: -(currentIndex * trackItemOffset) }}
        transition={effectiveTransition}
        onAnimationComplete={handleAnimationComplete}
      >
        {carouselItems.map((comic, index) => (
          <CarouselItem 
            key={index}
            comic={comic}
            index={index}
            x={x}
            currentIndex={currentIndex}
            trackItemOffset={trackItemOffset}
            itemWidth={itemWidth}
            round={round}
            effectiveTransition={effectiveTransition}
          />
        ))}
      </motion.div>
      <div
        className={`flex w-full justify-center ${round ? "absolute z-20 bottom-12 left-1/2 -translate-x-1/2" : "mt-6"
          }`}
      >
        <div className="flex w-[200px] justify-center gap-4 px-8">
          {items.map((_, index) => (
            <motion.div
              key={index}
              className={`h-3 w-3 rounded-full cursor-pointer transition-colors duration-150 ${
                currentIndex % items.length === index
                ? "bg-primary"
                : "bg-muted"
              }`}
              animate={{
                scale: currentIndex % items.length === index ? 1.2 : 1,
              }}
              onClick={() => setCurrentIndex(index)}
              transition={{ duration: 0.15 }}
            />
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/CircularGallery.tsx">
import { useRef, useEffect } from "react";
import {
  Renderer,
  Camera,
  Transform,
  Plane,
  Mesh,
  Program,
  Texture,
  Raycast,
} from "ogl";
import { useTheme } from "./theme-provider"; // Add this import

type GL = Renderer["gl"];

function debounce<T extends (...args: any[]) => void>(func: T, wait: number) {
  let timeout: number;
  return function (this: any, ...args: Parameters<T>) {
    window.clearTimeout(timeout);
    timeout = window.setTimeout(() => func.apply(this, args), wait);
  };
}

function lerp(p1: number, p2: number, t: number): number {
  return p1 + (p2 - p1) * t;
}

function autoBind(instance: any): void {
  const proto = Object.getPrototypeOf(instance);
  Object.getOwnPropertyNames(proto).forEach((key) => {
    if (key !== "constructor" && typeof instance[key] === "function") {
      instance[key] = instance[key].bind(instance);
    }
  });
}

function getFontSize(font: string): number {
  const match = font.match(/(\d+)px/);
  return match ? parseInt(match[1], 10) : 30;
}

function createTextTexture(
  gl: GL,
  text: string,
  font: string = "bold 30px monospace",
  color: string = "black"
): { texture: Texture; width: number; height: number } {
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  if (!context) throw new Error("Could not get 2d context");

  context.font = font;
  const metrics = context.measureText(text);
  const textWidth = Math.ceil(metrics.width);
  const fontSize = getFontSize(font);
  const textHeight = Math.ceil(fontSize * 1.2);

  canvas.width = textWidth + 20;
  canvas.height = textHeight + 20;

  context.font = font;
  context.fillStyle = color;
  context.textBaseline = "middle";
  context.textAlign = "center";
  context.clearRect(0, 0, canvas.width, canvas.height);
  context.fillText(text, canvas.width / 2, canvas.height / 2);

  const texture = new Texture(gl, { generateMipmaps: false });
  texture.image = canvas;
  return { texture, width: canvas.width, height: canvas.height };
}

interface TitleProps {
  gl: GL;
  plane: Mesh;
  renderer: Renderer;
  text: string;
  textColor?: string;
  font?: string;
}

class Title {
  gl: GL;
  plane: Mesh;
  renderer: Renderer;
  text: string;
  textColor: string;
  font: string;
  mesh!: Mesh;
  buttonMesh!: Mesh; // New property for button mesh

  constructor({
    gl,
    plane,
    renderer,
    text,
    textColor = "#545050",
    font = "30px sans-serif",
  }: TitleProps) {
    autoBind(this);
    this.gl = gl;
    this.plane = plane;
    this.renderer = renderer;
    this.text = text;
    this.textColor = textColor;
    this.font = font;
    this.createMesh();
    this.createViewDetailsButton(); // Add button creation
  }

  createMesh() {
    const { texture, width, height } = createTextTexture(
      this.gl,
      this.text,
      this.font,
      this.textColor
    );
    const geometry = new Plane(this.gl);
    const program = new Program(this.gl, {
      vertex: `
        attribute vec3 position;
        attribute vec2 uv;
        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragment: `
        precision highp float;
        uniform sampler2D tMap;
        varying vec2 vUv;
        void main() {
          vec4 color = texture2D(tMap, vUv);
          if (color.a < 0.1) discard;
          gl_FragColor = color;
        }
      `,
      uniforms: { tMap: { value: texture } },
      transparent: true,
    });
    this.mesh = new Mesh(this.gl, { geometry, program });
    const aspect = width / height;
    const textHeightScaled = this.plane.scale.y * 0.15;
    const textWidthScaled = textHeightScaled * aspect;
    this.mesh.scale.set(textWidthScaled, textHeightScaled, 1);
    this.mesh.position.y =
      -this.plane.scale.y * 0.5 - textHeightScaled * 0.5 - 0.05;
    this.mesh.setParent(this.plane);
  }

  createViewDetailsButton() {
    // Create a canvas for the button
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("Could not get 2d context");
    
    // Set button dimensions with padding
    const buttonText = "View";
    const fontSize = 24;
    ctx.font = `${fontSize}px ${this.font.replace(/bold \d+px/, '')}`;
    const metrics = ctx.measureText(buttonText);
    const textWidth = Math.ceil(metrics.width);
    const textHeight = Math.ceil(fontSize * 1.2);
    
    // Add padding and set canvas size
    const padding = 20;
    canvas.width = textWidth + padding * 2;
    canvas.height = textHeight + padding * 1.2;
    
    // Draw button background (theme-aware)
    ctx.fillStyle = this.gl.canvas.classList.contains('dark') ? '#3b82f6' : '#2563eb';
    
    // Create rounded rectangle
    const radius = Math.min(canvas.height / 3, 10);
    ctx.beginPath();
    ctx.moveTo(radius, 0);
    ctx.lineTo(canvas.width - radius, 0);
    ctx.quadraticCurveTo(canvas.width, 0, canvas.width, radius);
    ctx.lineTo(canvas.width, canvas.height - radius);
    ctx.quadraticCurveTo(canvas.width, canvas.height, canvas.width - radius, canvas.height);
    ctx.lineTo(radius, canvas.height);
    ctx.quadraticCurveTo(0, canvas.height, 0, canvas.height - radius);
    ctx.lineTo(0, radius);
    ctx.quadraticCurveTo(0, 0, radius, 0);
    ctx.closePath();
    ctx.fill();
    
    // Add slight shadow for depth
    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
    ctx.shadowBlur = 5;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 2;
    ctx.fill();
    
    // Draw text
    ctx.shadowColor = 'transparent';
    ctx.fillStyle = '#ffffff';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    ctx.fillText(buttonText, canvas.width / 2, canvas.height / 2);
    
    // Draw subtle border
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Create texture from canvas
    const texture = new Texture(this.gl, { generateMipmaps: false });
    texture.image = canvas;

    // Create button mesh with the texture
    const geometry = new Plane(this.gl);
    const program = new Program(this.gl, {
      vertex: `
        attribute vec3 position;
        attribute vec2 uv;
        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragment: `
        precision highp float;
        uniform sampler2D tMap;
        varying vec2 vUv;
        void main() {
          vec4 color = texture2D(tMap, vUv);
          gl_FragColor = color;
        }
      `,
      uniforms: { tMap: { value: texture } },
      transparent: true,
    });
    
    this.buttonMesh = new Mesh(this.gl, { geometry, program });
    
    // Scale and position button
    const aspect = canvas.width / canvas.height;
    const buttonHeightScaled = this.plane.scale.y * 0.13;
    const buttonWidthScaled = buttonHeightScaled * aspect;
    this.buttonMesh.scale.set(buttonWidthScaled, buttonHeightScaled, 1);
    
    // Position button below the title
    this.buttonMesh.position.y = 
      -this.plane.scale.y * 0.5 - this.mesh.scale.y - buttonHeightScaled * 0.5 - 0.05;
    
    this.buttonMesh.setParent(this.plane);
    
    // Add a property to identify this as a button for raycasting
    (this.buttonMesh as any).userData = { isViewDetailsButton: true };
  }
}

interface ScreenSize {
  width: number;
  height: number;
}

interface Viewport {
  width: number;
  height: number;
}

interface MediaProps {
  geometry: Plane;
  gl: GL;
  image: string;
  index: number;
  length: number;
  renderer: Renderer;
  scene: Transform;
  screen: ScreenSize;
  text: string;
  viewport: Viewport;
  bend: number;
  textColor: string;
  borderRadius?: number;
  font?: string;
}

class Media {
  extra: number = 0;
  geometry: Plane;
  gl: GL;
  image: string;
  index: number;
  length: number;
  renderer: Renderer;
  scene: Transform;
  screen: ScreenSize;
  text: string;
  viewport: Viewport;
  bend: number;
  textColor: string;
  borderRadius: number;
  font?: string;
  program!: Program;
  plane!: Mesh;
  title!: Title;
  scale!: number;
  padding!: number;
  width!: number;
  widthTotal!: number;
  x!: number;
  speed: number = 0;
  isBefore: boolean = false;
  isAfter: boolean = false;

  constructor({
    geometry,
    gl,
    image,
    index,
    length,
    renderer,
    scene,
    screen,
    text,
    viewport,
    bend,
    textColor,
    borderRadius = 0,
    font,
  }: MediaProps) {
    this.geometry = geometry;
    this.gl = gl;
    this.image = image;
    this.index = index;
    this.length = length;
    this.renderer = renderer;
    this.scene = scene;
    this.screen = screen;
    this.text = text;
    this.viewport = viewport;
    this.bend = bend;
    this.textColor = textColor;
    this.borderRadius = borderRadius;
    this.font = font;
    this.createShader();
    this.createMesh();
    this.createTitle();
    this.onResize();
  }

  createShader() {
    const texture = new Texture(this.gl, { generateMipmaps: false });
    this.program = new Program(this.gl, {
      depthTest: false,
      depthWrite: false,
      vertex: `
        precision highp float;
        attribute vec3 position;
        attribute vec2 uv;
        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;
        uniform float uTime;
        uniform float uSpeed;
        varying vec2 vUv;
        void main() {
          vUv = uv;
          vec3 p = position;
          p.z = (sin(p.x * 4.0 + uTime) * 1.5 + cos(p.y * 2.0 + uTime) * 1.5) * (0.1 + uSpeed * 0.5);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
        }
      `,
      fragment: `
        precision highp float;
        uniform vec2 uImageSizes;
        uniform vec2 uPlaneSizes;
        uniform sampler2D tMap;
        uniform float uBorderRadius;
        varying vec2 vUv;
        
        // Rounded box SDF for UV space
        float roundedBoxSDF(vec2 p, vec2 b, float r) {
          vec2 d = abs(p) - b;
          return length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0) - r;
        }
        
        void main() {
          vec2 ratio = vec2(
            min((uPlaneSizes.x / uPlaneSizes.y) / (uImageSizes.x / uImageSizes.y), 1.0),
            min((uPlaneSizes.y / uPlaneSizes.x) / (uImageSizes.y / uImageSizes.x), 1.0)
          );
          vec2 uv = vec2(
            vUv.x * ratio.x + (1.0 - ratio.x) * 0.5,
            vUv.y * ratio.y + (1.0 - ratio.y) * 0.5
          );
          vec4 color = texture2D(tMap, uv);
          
          // Apply rounded corners (assumes vUv in [0,1])
          float d = roundedBoxSDF(vUv - 0.5, vec2(0.5 - uBorderRadius), uBorderRadius);
          if(d > 0.0) {
            discard;
          }
          
          gl_FragColor = vec4(color.rgb, 1.0);
        }
      `,
      uniforms: {
        tMap: { value: texture },
        uPlaneSizes: { value: [0, 0] },
        uImageSizes: { value: [0, 0] },
        uSpeed: { value: 0 },
        uTime: { value: 100 * Math.random() },
        uBorderRadius: { value: this.borderRadius },
      },
      transparent: true,
    });
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = this.image;
    img.onload = () => {
      texture.image = img;
      this.program.uniforms.uImageSizes.value = [
        img.naturalWidth,
        img.naturalHeight,
      ];
    };
  }

  createMesh() {
    this.plane = new Mesh(this.gl, {
      geometry: this.geometry,
      program: this.program,
    });
    this.plane.setParent(this.scene);
  }

  createTitle() {
    this.title = new Title({
      gl: this.gl,
      plane: this.plane,
      renderer: this.renderer,
      text: this.text,
      textColor: this.textColor,
      font: this.font,
    });
  }

  update(
    scroll: { current: number; last: number },
    direction: "right" | "left"
  ) {
    this.plane.position.x = this.x - scroll.current - this.extra;

    const x = this.plane.position.x;
    const H = this.viewport.width / 2;

    if (this.bend === 0) {
      this.plane.position.y = 0;
      this.plane.rotation.z = 0;
    } else {
      const B_abs = Math.abs(this.bend);
      const R = (H * H + B_abs * B_abs) / (2 * B_abs);
      const effectiveX = Math.min(Math.abs(x), H);

      const arc = R - Math.sqrt(R * R - effectiveX * effectiveX);
      if (this.bend > 0) {
        this.plane.position.y = -arc;
        this.plane.rotation.z = -Math.sign(x) * Math.asin(effectiveX / R);
      } else {
        this.plane.position.y = arc;
        this.plane.rotation.z = Math.sign(x) * Math.asin(effectiveX / R);
      }
    }

    this.speed = scroll.current - scroll.last;
    this.program.uniforms.uTime.value += 0.04;
    this.program.uniforms.uSpeed.value = this.speed;

    const planeOffset = this.plane.scale.x / 2;
    const viewportOffset = this.viewport.width / 2;
    this.isBefore = this.plane.position.x + planeOffset < -viewportOffset;
    this.isAfter = this.plane.position.x - planeOffset > viewportOffset;
    if (direction === "right" && this.isBefore) {
      this.extra -= this.widthTotal;
      this.isBefore = this.isAfter = false;
    }
    if (direction === "left" && this.isAfter) {
      this.extra += this.widthTotal;
      this.isBefore = this.isAfter = false;
    }
  }

  onResize({
    screen,
    viewport,
  }: { screen?: ScreenSize; viewport?: Viewport } = {}) {
    if (screen) this.screen = screen;
    if (viewport) {
      this.viewport = viewport;
      if (this.plane.program.uniforms.uViewportSizes) {
        this.plane.program.uniforms.uViewportSizes.value = [
          this.viewport.width,
          this.viewport.height,
        ];
      }
    }
    this.scale = this.screen.height / 1500;
    this.plane.scale.y =
      (this.viewport.height * (900 * this.scale)) / this.screen.height;
    this.plane.scale.x =
      (this.viewport.width * (700 * this.scale)) / this.screen.width;
    this.plane.program.uniforms.uPlaneSizes.value = [
      this.plane.scale.x,
      this.plane.scale.y,
    ];
    this.padding = 2;
    this.width = this.plane.scale.x + this.padding;
    this.widthTotal = this.width * this.length;
    this.x = this.width * this.index;
  }

  // Add a method to check if a mesh is this media's button
  isViewDetailsButton(mesh: Mesh): boolean {
    return mesh === this.title.buttonMesh;
  }
}

interface AppConfig {
  items?: { image: string; text: string }[];
  bend?: number;
  textColor?: string;
  borderRadius?: number;
  font?: string;
  isDarkTheme?: boolean; // Add this property
  onItemClick?: (index: number) => void; // Add click handler prop
}

class App {
  container: HTMLElement;
  scroll: {
    ease: number;
    current: number;
    target: number;
    last: number;
    position?: number;
  };
  onCheckDebounce: (...args: any[]) => void;
  renderer!: Renderer;
  gl!: GL;
  camera!: Camera;
  scene!: Transform;
  planeGeometry!: Plane;
  medias: Media[] = [];
  mediasImages: { image: string; text: string }[] = [];
  screen!: { width: number; height: number };
  viewport!: { width: number; height: number };
  raf: number = 0;
  raycast!: Raycast;

  boundOnResize!: () => void;
  boundOnWheel!: () => void;
  boundOnTouchDown!: (e: MouseEvent | TouchEvent) => void;
  boundOnTouchMove!: (e: MouseEvent | TouchEvent) => void;
  boundOnTouchUp!: () => void;

  isDown: boolean = false;
  start: number = 0;
  isDarkTheme: boolean = false; // Add this property
  onItemClick?: (index: number) => void; // Add click handler prop

  constructor(
    container: HTMLElement,
    {
      items,
      bend = 1,
      textColor = "#ffffff",
      borderRadius = 0,
      font = "bold 30px DM Sans",
      isDarkTheme = false, // Add this parameter
      onItemClick, // Add this parameter
    }: AppConfig
  ) {
    document.documentElement.classList.remove("no-js");
    this.container = container;
    this.scroll = { ease: 0.05, current: 0, target: 0, last: 0 };
    this.onCheckDebounce = debounce(this.onCheck.bind(this), 200);
    this.isDarkTheme = isDarkTheme; // Store the theme state
    this.onItemClick = onItemClick; // Store the click handler
    this.createRenderer();
    this.createCamera();
    this.createScene();
    this.onResize();
    this.createGeometry();
    this.createMedias(items, bend, textColor, borderRadius, font);
    this.raycast = new Raycast();
    this.renderer.gl.canvas.addEventListener('click', this.onCanvasClick.bind(this));
    this.update();
    this.addEventListeners();
  }

  createRenderer() {
    this.renderer = new Renderer({ alpha: true });
    this.gl = this.renderer.gl;
    // Use background color based on theme
    this.gl.clearColor(0, 0, 0, 0);
    this.container.appendChild(this.renderer.gl.canvas as HTMLCanvasElement);
  }

  createCamera() {
    this.camera = new Camera(this.gl);
    this.camera.fov = 45;
    this.camera.position.z = 20;
  }

  createScene() {
    this.scene = new Transform();
  }

  createGeometry() {
    this.planeGeometry = new Plane(this.gl, {
      heightSegments: 50,
      widthSegments: 100,
    });
  }

  createMedias(
    items: { image: string; text: string }[] | undefined,
    bend: number = 1,
    textColor: string,
    borderRadius: number,
    font: string
  ) {
    const defaultItems = [
      {
        image: `https://picsum.photos/seed/1/800/600?grayscale`,
        text: "Bridge",
      },
      {
        image: `https://picsum.photos/seed/2/800/600?grayscale`,
        text: "Desk Setup",
      },
      {
        image: `https://picsum.photos/seed/3/800/600?grayscale`,
        text: "Waterfall",
      },
      {
        image: `https://picsum.photos/seed/4/800/600?grayscale`,
        text: "Strawberries",
      },
      {
        image: `https://picsum.photos/seed/5/800/600?grayscale`,
        text: "Deep Diving",
      },
      {
        image: `https://picsum.photos/seed/16/800/600?grayscale`,
        text: "Train Track",
      },
      {
        image: `https://picsum.photos/seed/17/800/600?grayscale`,
        text: "Santorini",
      },
      {
        image: `https://picsum.photos/seed/8/800/600?grayscale`,
        text: "Blurry Lights",
      },
      {
        image: `https://picsum.photos/seed/9/800/600?grayscale`,
        text: "New York",
      },
      {
        image: `https://picsum.photos/seed/10/800/600?grayscale`,
        text: "Good Boy",
      },
      {
        image: `https://picsum.photos/seed/21/800/600?grayscale`,
        text: "Coastline",
      },
      {
        image: `https://picsum.photos/seed/12/800/600?grayscale`,
        text: "Palm Trees",
      },
    ];
    const galleryItems = items && items.length ? items : defaultItems;
    this.mediasImages = galleryItems.concat(galleryItems);
    this.medias = this.mediasImages.map((data, index) => {
      return new Media({
        geometry: this.planeGeometry,
        gl: this.gl,
        image: data.image,
        index,
        length: this.mediasImages.length,
        renderer: this.renderer,
        scene: this.scene,
        screen: this.screen,
        text: data.text,
        viewport: this.viewport,
        bend,
        textColor,
        borderRadius,
        font,
      });
    });
  }

  onTouchDown(e: MouseEvent | TouchEvent) {
    this.isDown = true;
    this.scroll.position = this.scroll.current;
    this.start = "touches" in e ? e.touches[0].clientX : e.clientX;
  }

  onTouchMove(e: MouseEvent | TouchEvent) {
    if (!this.isDown) return;
    const x = "touches" in e ? e.touches[0].clientX : e.clientX;
    const distance = (this.start - x) * 0.05;
    this.scroll.target = (this.scroll.position ?? 0) + distance;
  }

  onTouchUp() {
    this.isDown = false;
    this.onCheck();
  }

  onWheel() {
    this.scroll.target += 2;
    this.onCheckDebounce();
  }

  onCheck() {
    if (!this.medias || !this.medias[0]) return;
    const width = this.medias[0].width;
    const itemIndex = Math.round(Math.abs(this.scroll.target) / width);
    const item = width * itemIndex;
    this.scroll.target = this.scroll.target < 0 ? -item : item;
  }

  onResize() {
    this.screen = {
      width: this.container.clientWidth,
      height: this.container.clientHeight,
    };
    this.renderer.setSize(this.screen.width, this.screen.height);
    this.camera.perspective({
      aspect: this.screen.width / this.screen.height,
    });
    const fov = (this.camera.fov * Math.PI) / 180;
    const height = 2 * Math.tan(fov / 2) * this.camera.position.z;
    const width = height * this.camera.aspect;
    this.viewport = { width, height };
    if (this.medias) {
      this.medias.forEach((media) =>
        media.onResize({ screen: this.screen, viewport: this.viewport })
      );
    }
  }

  update() {
    this.scroll.current = lerp(
      this.scroll.current,
      this.scroll.target,
      this.scroll.ease
    );
    const direction = this.scroll.current > this.scroll.last ? "right" : "left";
    if (this.medias) {
      this.medias.forEach((media) => media.update(this.scroll, direction));
    }
    this.renderer.render({ scene: this.scene, camera: this.camera });
    this.scroll.last = this.scroll.current;
    this.raf = window.requestAnimationFrame(this.update.bind(this));
  }

  addEventListeners() {
    this.boundOnResize = this.onResize.bind(this);
    this.boundOnWheel = this.onWheel.bind(this);
    this.boundOnTouchDown = this.onTouchDown.bind(this);
    this.boundOnTouchMove = this.onTouchMove.bind(this);
    this.boundOnTouchUp = this.onTouchUp.bind(this);
    window.addEventListener("resize", this.boundOnResize);
    window.addEventListener("mousewheel", this.boundOnWheel);
    window.addEventListener("wheel", this.boundOnWheel);
    window.addEventListener("mousedown", this.boundOnTouchDown);
    window.addEventListener("mousemove", this.boundOnTouchMove);
    window.addEventListener("mouseup", this.boundOnTouchUp);
    window.addEventListener("touchstart", this.boundOnTouchDown);
    window.addEventListener("touchmove", this.boundOnTouchMove);
    window.addEventListener("touchend", this.boundOnTouchUp);
  }

  onCanvasClick(event: MouseEvent) {
    const rect = this.renderer.gl.canvas.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    
    this.raycast.castMouse(this.camera, [x, y]);
    
    // Get all meshes to check (including buttons)
    const allMeshes: Mesh[] = [];
    this.medias.forEach(media => {
      allMeshes.push(media.plane);
      allMeshes.push(media.title.buttonMesh);
    });
    
    const hits = this.raycast.intersectBounds(allMeshes);
    
    if (hits.length > 0) {
      const hitMesh = hits[0];
      
      // Only trigger navigation if the hit mesh is a button
      for (const media of this.medias) {
        if (media.isViewDetailsButton(hitMesh)) {
          if (this.onItemClick) {
            this.onItemClick(media.index);
          }
          break;
        }
      }
    }
  }

  destroy() {
    window.cancelAnimationFrame(this.raf);
    window.removeEventListener("resize", this.boundOnResize);
    window.removeEventListener("mousewheel", this.boundOnWheel);
    window.removeEventListener("wheel", this.boundOnWheel);
    window.removeEventListener("mousedown", this.boundOnTouchDown);
    window.removeEventListener("mousemove", this.boundOnTouchMove);
    window.removeEventListener("mouseup", this.boundOnTouchUp);
    window.removeEventListener("touchstart", this.boundOnTouchDown);
    window.removeEventListener("touchmove", this.boundOnTouchMove);
    window.removeEventListener("touchend", this.boundOnTouchUp);
    this.renderer.gl.canvas.removeEventListener('click', this.onCanvasClick);
    if (
      this.renderer &&
      this.renderer.gl &&
      this.renderer.gl.canvas.parentNode
    ) {
      this.renderer.gl.canvas.parentNode.removeChild(
        this.renderer.gl.canvas as HTMLCanvasElement
      );
    }
  }
}

interface CircularGalleryItem {
  image: string;
  text: string;
  slug?: string; // Add slug property (optional for backward compatibility)
}

interface CircularGalleryProps {
  items?: CircularGalleryItem[];
  bend?: number;
  textColor?: string;
  borderRadius?: number;
  font?: string;
  onItemClick?: (index: number) => void; // Add click handler prop
}

export default function CircularGallery({
  items,
  bend = 3,
  borderRadius = 0.05,
  font = "bold 30px DM Sans",
  textColor: propTextColor,
  onItemClick, // Add click handler prop
}: CircularGalleryProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const { theme } = useTheme(); // Get the current theme
  const isDarkTheme = theme === 'dark';
  
  // Determine text color based on theme if not explicitly provided
  const textColor = propTextColor || (isDarkTheme ? "#ffffff" : "#545050");
  
  useEffect(() => {
    if (!containerRef.current) return;
    
    // Clean up previous instance if it exists
    if (containerRef.current.childNodes.length > 0) {
      containerRef.current.innerHTML = '';
    }
    
    const app = new App(containerRef.current, {
      items,
      bend,
      textColor,
      borderRadius,
      font,
      isDarkTheme,
      onItemClick, // Pass click handler to App
    });
    
    return () => {
      app.destroy();
    };
  }, [items, bend, textColor, borderRadius, font, isDarkTheme, theme, onItemClick]); // Add onItemClick to dependencies
  
  return (
    <div
      className="w-full h-full overflow-hidden cursor-grab active:cursor-grabbing"
      ref={containerRef}
    />
  );
}
</file>

<file path="src/components/layout/Footer.tsx">
import { Link } from 'react-router-dom'
import { AlertCircle } from 'lucide-react'
import path from '../../constants/path'

const Footer = () => {
  return (
    <footer className='border-t bg-background py-6 md:py-10'>
      <div className='container flex flex-col items-center justify-between gap-4 px-4 md:flex-row md:px-6'>
        <div className='flex flex-col items-center gap-4 md:items-start'>
          <Link to={path.home} className='flex items-center space-x-2'>
            <AlertCircle className='h-6 w-6 text-primary' />
            <span className='font-bold'>NON TRUYỆN</span>
          </Link>
          <p className='text-center text-sm text-muted-foreground md:text-left'>
            © {new Date().getFullYear()} NONTRUYEN. All rights reserved.
          </p>
        </div>

        <div className='flex flex-wrap justify-center gap-x-8 gap-y-4 md:justify-end'>
          <Link to={path.feedback} className='text-sm hover:underline'>
            Privacy Policy
          </Link>
        </div>
      </div>
    </footer>
  )
}

export default Footer
</file>

<file path="src/components/layout/MainLayout.tsx">
import { ReactNode } from 'react'
import Header from './Header'
import Footer from './Footer'

interface MainLayoutProps {
  children: ReactNode
}

const MainLayout = ({ children }: MainLayoutProps) => {
  return (
    <div className='flex min-h-screen flex-col'>
      <Header />
      <main className='flex-1'>{children}</main>
      <Footer />
    </div>
  )
}

export default MainLayout
</file>

<file path="src/components/mode-toggle.tsx">
import { Moon, Sun } from "lucide-react"

import { Button } from "../components/ui/button"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "../components/ui/dropdown-menu"
import { useTheme } from "./theme-provider"

export function ModeToggle() {
  const { setTheme } = useTheme()

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
       
      </DropdownMenuContent>
    </DropdownMenu>
  )
}
</file>

<file path="src/components/SpotlightCard.tsx">
import React, { useRef, useState } from "react";

interface Position {
  x: number;
  y: number;
}

interface SpotlightCardProps extends React.PropsWithChildren {
  className?: string;
  spotlightColor?: `rgba(${number}, ${number}, ${number}, ${number})`;
}

const SpotlightCard: React.FC<SpotlightCardProps> = ({
  children,
  className = "",
  spotlightColor = "rgba(255, 255, 255, 0.25)"
}) => {
  const divRef = useRef<HTMLDivElement>(null);
  const [isFocused, setIsFocused] = useState<boolean>(false);
  const [position, setPosition] = useState<Position>({ x: 0, y: 0 });
  const [opacity, setOpacity] = useState<number>(0);

  const handleMouseMove: React.MouseEventHandler<HTMLDivElement> = (e) => {
    if (!divRef.current || isFocused) return;

    const rect = divRef.current.getBoundingClientRect();
    setPosition({ x: e.clientX - rect.left, y: e.clientY - rect.top });
  };

  const handleFocus = () => {
    setIsFocused(true);
    setOpacity(0.6);
  };

  const handleBlur = () => {
    setIsFocused(false);
    setOpacity(0);
  };

  const handleMouseEnter = () => {
    setOpacity(0.6);
  };

  const handleMouseLeave = () => {
    setOpacity(0);
  };

  return (
    <div
      ref={divRef}
      onMouseMove={handleMouseMove}
      onFocus={handleFocus}
      onBlur={handleBlur}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      className={`relative rounded-3xl border border-neutral-800 bg-neutral-900 overflow-hidden p-8 ${className}`}
    >
      <div
        className="pointer-events-none absolute inset-0 opacity-0 transition-opacity duration-500 ease-in-out"
        style={{
          opacity,
          background: `radial-gradient(circle at ${position.x}px ${position.y}px, ${spotlightColor}, transparent 80%)`,
        }}
      />
      {children}
    </div>
  );
};

export default SpotlightCard;
</file>

<file path="src/components/theme-provider.tsx">
import { createContext, useContext, useEffect, useState } from "react"

type Theme = "dark" | "light" | "system"

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) => void
}

const initialState: ThemeProviderState = {
  theme: "system",
  setTheme: () => null,
}

const ThemeProviderContext = createContext<ThemeProviderState>(initialState)

export function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "vite-ui-theme",
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
  )

  useEffect(() => {
    const root = window.document.documentElement

    root.classList.remove("light", "dark")

    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
        .matches
        ? "dark"
        : "light"

      root.classList.add(systemTheme)
      return
    }

    root.classList.add(theme)
  }, [theme])

  useEffect(() => {
    // Add listener for system theme changes
    if (theme === "system") {
      const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)")
      
      const handleChange = () => {
        const root = window.document.documentElement
        root.classList.remove("light", "dark")
        root.classList.add(mediaQuery.matches ? "dark" : "light")
      }
      
      mediaQuery.addEventListener("change", handleChange)
      return () => mediaQuery.removeEventListener("change", handleChange)
    }
  }, [theme])

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme)
      setTheme(theme)
    },
  }

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  )
}

export const useTheme = () => {
  const context = useContext(ThemeProviderContext)

  if (context === undefined)
    throw new Error("useTheme must be used within a ThemeProvider")

  return context
}
</file>

<file path="src/components/ui/avatar.tsx">
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "../../lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="src/components/ui/dropdown-menu.tsx">
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "../../lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "../../lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="src/components/ui/sonner.tsx">
import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="src/constants/config.ts">
const config = {
    baseURL: 'https://otruyenapi.com/v1/api/',
    maxSizeUploadAvatar: 1048576
  }
  export default config
</file>

<file path="src/constants/path.ts">
const path = {
  home: '/',
  login: '/login',
  register: '/register',
  profile: '/profile',
  changePassword: '/change-password',
  forgotPassword: '/forgot-password',
  resetPassword: '/reset-password',
  verifyEmail: '/verify-email',
  logout: '/logout',
  healthAZ: '/health-a-z',
  disease: '/health-a-z/:id',
  medicines: '/drugs-and-supplements',
  medicine: '/drugs-and-supplements/:id',
  orders: '/orders',
  order: '/orders/:id',
  checkout: '/checkout',
  paymentSuccess: '/payment-success',
  doctors: '/doctors',
  doctor: '/doctors/:id',
  doctorSymptomSearch: '/doctors/search/symptoms',
  appointments: '/appointments',
  appointment: '/appointments/:id',
  appointmentBooking: '/appointments/book/:doctorId',
  feedback: '/feedback',
  comicDetail: '/truyen-tranh/:slug',
  chapter: '/truyen-tranh/:slug/chapter/:chapterNumber'
};

export default path;
</file>

<file path="src/hooks/useDebounce.ts">
import { useEffect, useState } from 'react';

/**
 * A hook that delays updating a value until a specified delay has passed
 * Useful for reducing API calls when user is typing
 * 
 * @param value - The value to debounce
 * @param delay - Delay in milliseconds
 * @returns The debounced value
 */
export function useDebounce<T>(value: T, delay: number = 500): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // Set a timeout to update the debounced value after the delay
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Clean up the timeout if the value changes again before the delay has passed
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}
</file>

<file path="src/index.css">
@import "tailwindcss";
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import './App.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="src/pages/Category/index.ts">
import CategoryPage from "./CategoryPage";

export default CategoryPage;
</file>

<file path="src/pages/ChapterDetail/ChapterDetail.tsx">
import React, { useEffect, useState, useRef } from "react";
import { useParams, Link, useNavigate } from "react-router-dom";
import useComicStore from "../../store/comicStore";

const ChapterDetail = () => {
  const { slug, chapterName } = useParams<{
    slug: string;
    chapterName: string;
  }>();
  const navigate = useNavigate();
  const topRef = useRef<HTMLDivElement>(null);

  // Get state and actions from store
  const {
    currentComic,
    currentChapter,
    isLoadingComicDetail,
    isLoadingChapter,
    error,
    fetchComicDetail,
    fetchChapterDetail,
  } = useComicStore();

  // Local state for image loading and UI
  const [loadedImages, setLoadedImages] = useState<Record<number, boolean>>({});
  const [showChapterSelect, setShowChapterSelect] = useState<boolean>(false);
  const [forceShowImages, setForceShowImages] = useState<boolean>(false);

  // Fetch comic details if not loaded
  useEffect(() => {
    if (!slug) return;

    if (!currentComic || currentComic.slug !== slug) {
      fetchComicDetail(slug);
    }
  }, [slug, currentComic, fetchComicDetail]);

  // Get current chapter URL and fetch chapter details
  useEffect(() => {
    if (!currentComic || !chapterName) return;

    // Find chapter in all servers
    const allChapters = currentComic.chapters.flatMap(
      (server) => server.chapters
    );
    const selectedChapter = allChapters.find(
      (chapter) => chapter.name === chapterName
    );

    if (selectedChapter) {
      fetchChapterDetail(selectedChapter.url);
    }
  }, [currentComic, chapterName, fetchChapterDetail]);

  // Reset loaded images state when chapter changes
  useEffect(() => {
    setLoadedImages({});
    setForceShowImages(false);

    // Force show images after a timeout in case events don't fire
    const timer = setTimeout(() => {
      console.log("Force showing images after timeout");
      setForceShowImages(true);
    }, 1000);

    return () => clearTimeout(timer);
  }, [chapterName]);

  // Image loading tracker - improved version
  const handleImageLoad = (page: number) => {
    setLoadedImages((prev) => ({
      ...prev,
      [page]: true,
    }));
  };

  // Add error handling for images
  const handleImageError = (page: number) => {
    console.error(`Failed to load image ${page}`);
    // Mark as loaded anyway to remove the loading indicator
    setLoadedImages((prev) => ({
      ...prev,
      [page]: true,
    }));
  };

  // Get next and previous chapters
  const getAdjacentChapters = () => {
    if (!currentComic) return { nextChapter: null, prevChapter: null };

    const allChapters = currentComic.chapters.flatMap(
      (server) => server.chapters
    );
    const currentIndex = allChapters.findIndex(
      (chapter) => chapter.name === chapterName
    );

    return {
      nextChapter: currentIndex > 0 ? allChapters[currentIndex - 1] : null,
      prevChapter:
        currentIndex < allChapters.length - 1
          ? allChapters[currentIndex + 1]
          : null,
    };
  };

  const { nextChapter, prevChapter } = getAdjacentChapters();

  // Function to handle chapter change from dropdown
  const handleChapterChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const selectedChapterName = event.target.value;
    if (selectedChapterName) {
      navigate(`/truyen-tranh/${slug}/chapter/${selectedChapterName}`);
    }
  };

  // Scroll to top function
  const scrollToTop = () => {
    topRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  // Toggle chapter select dropdown
  const toggleChapterSelect = () => {
    setShowChapterSelect((prev) => !prev);
  };

  // Loading state
  if (isLoadingComicDetail || isLoadingChapter) {
    return (
      <div className="flex items-center justify-center min-h-[80vh]">
        <div className="text-xl">Loading chapter...</div>
      </div>
    );
  }

  // Error state
  if (error || !currentComic || !currentChapter) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[80vh] space-y-4">
        <div className="text-xl text-red-500">
          {error || "Chapter not found"}
        </div>
        <Link 
          to={`/truyen-tranh/${slug}`} 
          className="px-4 py-2 bg-secondary hover:bg-secondary/90 rounded-md transition-colors"
        >
          Back to Comic
        </Link>
      </div>
    );
  }

  // All chapters for dropdown
  const allChapters = currentComic.chapters.flatMap(
    (server) => server.chapters
  );

  return (
    <div className="flex flex-col items-center pb-20" ref={topRef}>
      {/* Chapter header */}
      <div className="w-full bg-background/50 dark:bg-black/50 sticky top-0 z-10 backdrop-blur-md py-4 px-4 border-b">
        <div className="max-w-7xl mx-auto flex flex-col md:flex-row justify-between items-center gap-4">
          <div className="text-center md:text-left">
            <h1 className="text-lg md:text-xl font-bold">
              {currentComic.title}
            </h1>
            <h2 className="text-base text-muted-foreground">
              Chapter {currentChapter.chapterName}
              {currentChapter.chapterTitle &&
                ` - ${currentChapter.chapterTitle}`}
            </h2>
          </div>

          {/* Navigation with chapter selection */}
          <div className="flex items-center space-x-2">
            <select
              value={chapterName}
              onChange={handleChapterChange}
              className="px-3 py-1 bg-secondary text-secondary-foreground rounded-md text-sm"
              aria-label="Select chapter"
            >
              {allChapters.map((chapter) => (
                <option key={chapter.name} value={chapter.name}>
                  Chapter {chapter.name}{" "}
                  {chapter.title ? `- ${chapter.title}` : ""}
                </option>
              ))}
            </select>

            <Link
              to={`/truyen-tranh/${slug}`}
              className="px-3 py-1 bg-secondary hover:bg-secondary/90 text-secondary-foreground rounded-md text-sm"
              aria-label="Back to comic details"
            >
              ⓘ Info
            </Link>

            {nextChapter && (
              <Link
                to={`/truyen-tranh/${slug}/chapter/${nextChapter.name}`}
                className="px-3 py-1 bg-primary hover:bg-primary/90 text-primary-foreground rounded-md text-sm"
                aria-label="Next chapter"
              >
                ← Previous
              </Link>
            )}

            {prevChapter && (
              <Link
                to={`/truyen-tranh/${slug}/chapter/${prevChapter.name}`}
                className="px-3 py-1 bg-secondary hover:bg-secondary/90 text-secondary-foreground rounded-md text-sm"
                aria-label="Previous chapter"
              >
                Next →
              </Link>
            )}
          </div>
        </div>
      </div>

      {/* Chapter Images */}
      <div className="max-w-4xl w-full mx-auto px-4 mt-8">
        {currentChapter.images.map((image, index) => {
          // Generate a guaranteed unique key for this render
          const imageKey =
            image.uniqueId ||
            `${slug}-${currentChapter.chapterName}-${index}-${Date.now()}`;
          const isLoaded = loadedImages[image.page];

          return (
            <div key={imageKey} className="flex flex-col items-center">
              {/* Loading placeholder - only show if not loaded and not force showing */}
              {!isLoaded && !forceShowImages && (
                <div className="w-full h-[300px] bg-muted flex items-center justify-center">
                  <div className="text-muted-foreground">
                    Loading image {image.page}...
                  </div>
                </div>
              )}

              {/* Actual image - Improved visibility logic */}
              <img
                src={image.imageUrl}
                alt={`Page ${image.page}`}
                className={`w-full object-contain ${
                  isLoaded || forceShowImages ? "block" : ""
                }`}
                onLoad={() => handleImageLoad(image.page)}
                onError={() => handleImageError(image.page)}
                loading="lazy"
              />
            </div>
          );
        })}
      </div>

      {/* Next or Previous chap */}
        <div className="w-full max-w-4xl mx-auto px-4 mt-8 flex justify-between">
          
        {nextChapter && (
            <Link
                to={`/truyen-tranh/${slug}/chapter/${nextChapter.name}`}
                className="px-3 py-2 bg-primary hover:bg-primary/90 text-primary-foreground rounded-md text-sm"
                aria-label="Next chapter"
            >
              ← Previous Chapter
            </Link>
            )}
            {prevChapter && (
            <Link
                to={`/truyen-tranh/${slug}/chapter/${prevChapter.name}`}
                className="px-3 py-2 bg-secondary hover:bg-secondary/90 text-secondary-foreground rounded-md text-sm"
                aria-label="Previous chapter"
            >
                  Next Chapter →
               
            </Link>
            )}
    
            </div>

      {/* Left side chapter navigation */}
      <div className="fixed bottom-16 left-4 z-20">
        <div className="flex flex-col bg-background/70 dark:bg-black/70 backdrop-blur-md rounded-lg overflow-hidden border shadow-md">
          <button
            onClick={toggleChapterSelect}
            className="px-4 py-2 bg-secondary hover:bg-secondary/90 text-sm w-full text-left flex justify-between items-center"
          >
            <span>Chapter {chapterName}</span>
            <span>{showChapterSelect ? "▲" : "▼"}</span>
          </button>

          {showChapterSelect && (
            <div className="max-h-48 overflow-y-auto bg-background dark:bg-card p-2">
              {allChapters.map((chapter) => (
                <Link
                  key={chapter.name}
                  to={`/truyen-tranh/${slug}/chapter/${chapter.name}`}
                  className={`block px-2 py-1 rounded text-sm ${
                    chapter.name === chapterName
                      ? "bg-primary text-primary-foreground"
                      : "hover:bg-secondary/50"
                  }`}
                >
                  Chapter {chapter.name}
                </Link>
              ))}
            </div>
          )}
          <div className="flex">
            {nextChapter && (
              <Link
                to={`/truyen-tranh/${slug}/chapter/${nextChapter.name}`}
                className="px-2 py-2 bg-primary hover:bg-primary/90 text-primary-foreground text-xs flex-1 text-center"
                aria-label="Next chapter"
              >
                ← Prev
              </Link>
            )}

            {prevChapter && (
              <Link
                to={`/truyen-tranh/${slug}/chapter/${prevChapter.name}`}
                className="px-2 py-2 bg-secondary hover:bg-secondary/90 text-secondary-foreground text-xs flex-1 text-center"
                aria-label="Previous chapter"
              >
                Next →
              </Link>
            )}
          </div>
        </div>
      </div>

      {/* Scroll to top button */}
      <button
        onClick={scrollToTop}
        className="fixed bottom-16 right-4 z-20 p-3 bg-primary hover:bg-primary/90 text-primary-foreground rounded-full shadow-lg"
        aria-label="Scroll to top"
      >
        ↑
      </button>
    </div>
  );
};

export default ChapterDetail;
</file>

<file path="src/pages/ChapterDetail/index.ts">
import ChapterDetail from "./ChapterDetail";

export default ChapterDetail;
</file>

<file path="src/pages/ComicDetail/index.ts">
import ComicDetail from './ComicDetail';
export default ComicDetail;
</file>

<file path="src/pages/HomePage/index.tsx">
import HomePage from './HomePage'

export default HomePage
</file>

<file path="src/pages/NewComic/index.tsx">
import NewComic from "./NewComic";

export default NewComic;
</file>

<file path="src/pages/SearchPage/index.ts">
import SearchPage from "./SearchPage";

export default SearchPage;
</file>

<file path="src/store/authStore.ts">
import { create } from 'zustand'
import { getAccessTokenFromLS, removeAccessTokenFromLS } from '../utils/auth'

interface User {
  id?: string
  email?: string
  name?: string
  avatar?: string
}

interface AuthState {
  isAuthenticated: boolean
  user: User | null
  setUser: (user: User) => void
  logout: () => void
}

const useAuthStore = create<AuthState>((set) => ({
  isAuthenticated: Boolean(getAccessTokenFromLS()),
  user: null,
  setUser: (user) => set({ user, isAuthenticated: true }),
  logout: () => {
    removeAccessTokenFromLS()
    set({ user: null, isAuthenticated: false })
  }
}))

export default useAuthStore
</file>

<file path="src/types/Category.type.ts">
/**
 * Interface representing a category in the system
 */
export interface Category {
  /**
   * Unique identifier for the category (MongoDB ObjectId)
   */
  _id: string;
  
  /**
   * URL-friendly slug for the category
   */
  slug: string;
  
  /**
   * Display name of the category
   */
  name: string;
}

/**
 * Type for the API response containing categories
 */
export interface CategoryApiResponse {
  status: string;
  message: string;
  data: {
    items: Category[];
  };
}
</file>

<file path="src/types/Comic.type.ts">
// Base Interface cho các thông tin chung
export interface ComicBase {
    id: string;
    title: string;
    slug: string;
    thumbnail: string;
    status: 'ongoing' | 'completed';
    genres: string[];
  }
  
  // Type cho Carousel (chỉ cần thông tin cơ bản)
  export interface ComicCarousel extends ComicBase {
    latestChapter: {
      chapterName: string;
      chapterUrl: string;
    };
    og_image?: string; // Add og_image property for thumbnails
    origin_name?: string[]; // Add origin_name property for display
    thumb_url?: string; // Add the original thumb_url for direct access
    updatedAt?: string; // Add updatedAt property for display
  }
  
  // Type chi tiết cho trang thông tin truyện
  export interface Comic extends ComicBase {
    content: string;
    authors: string[];
    chapters: Chapter[];
    seoInfo?: {
      title: string;
      description: string;
      ogImage: string;
    };
    origin_name: string[]; // Add origin_name property for display
  }
  
  // Phụ type cho chapter
  export interface Chapter {
    serverName: string;
    chapters: {
      name: string;
      url: string;
      title?: string;
    }[];
  }

  // Interface for chapter detail
  export interface ChapterDetail {
    chapterName: string;
    chapterTitle: string;
    images: ChapterImage[];
  }
  
  export interface ChapterImage {
    page: number;
    imageUrl: string;
    uniqueIndex?: number; // Keep for backward compatibility
    uniqueId: string;     // Add new unique identifier
  }
  
  // Helper function map API data
  export const mapToComicCarousel = (apiData: any, cdnUrl: string): ComicCarousel => ({
    id: apiData._id,
    title: apiData.name,
    slug: apiData.slug,
    thumbnail: `${cdnUrl}/uploads/comics/${apiData.thumb_url}`,
    status: apiData.status,
    genres: apiData.category.map((cat: any) => cat.name),
    latestChapter: {
      chapterName: apiData.chaptersLatest?.[0]?.chapter_name || '',
      chapterUrl: apiData.chaptersLatest?.[0]?.chapter_api_data || ''
    },
    og_image: apiData.thumb_url ? `/uploads/comics/${apiData.thumb_url}` : '',
    origin_name: apiData.origin_name || [],
    thumb_url: apiData.thumb_url,
    updatedAt: apiData.updatedAt || ''
  });
  
  export const mapToComicDetail = (apiData: any, cdnUrl: string): Comic => ({
    ...mapToComicCarousel(apiData, cdnUrl),
    content: apiData.content,
    authors: apiData.author || [],
    chapters: apiData.chapters.map((server: any) => ({
      serverName: server.server_name,
      chapters: server.server_data.map((chap: any) => ({
        name: chap.chapter_name,
        url: chap.chapter_api_data,
        title: chap.chapter_title
      }))
    })),
    seoInfo: {
      title: apiData.seoOnPage?.titleHead || '',
      description: apiData.seoOnPage?.descriptionHead || '',
      ogImage: `${cdnUrl}/uploads/${apiData.seoOnPage?.og_image?.[0] || ''}`
    },
    origin_name: apiData.origin_name || []
  });

  // Helper function to map chapter detail API data
  export const mapToChapterDetail = (apiChapter: any, domainCdn: string): ChapterDetail => {
    return {
      chapterName: apiChapter.chapter_name,
      chapterTitle: apiChapter.chapter_title || '',
      images: apiChapter.chapter_image.map((img: any) => ({
        page: img.image_page,
        // Correctly construct the full image URL by combining domain_cdn + chapter_path + image_file
        imageUrl: `${domainCdn}/${apiChapter.chapter_path}/${img.image_file}`
      }))
    };
  };
</file>

<file path="src/types/User.type.ts">
export interface User {
    _id: string
    name: string
    email: string
    date_of_birth: string
    bio: string
    location: string
    phone: string
    username: string
    avatar: string
    account_type: number
    verify: number
    created_at: string
    updated_at: string
  }
  
  export interface LoginResponse {
    access_token: string
    refresh_token: string
    user: User
  }
  
  export interface RegisterType {
    name: string
    email: string
    password: string
    confirm_password: string
    date_of_birth: string
  }
</file>

<file path="src/types/Utils.type.ts">
export interface SuccessResponse<Data> {
  message: string
  result: Data
}
</file>

<file path="src/utils/auth.ts">
import { User } from '../types/User.type'

export const localStorageEventTarget = new EventTarget()

export const setAccessTokenToLS = (access_token: string) => {
  localStorage.setItem('access_token', access_token)
}

export const setRefreshTokenToLS = (refresh_token: string) => {
  localStorage.setItem('refresh_token', refresh_token)
}

export const saveAccessTokenToLS = (access_token: string) => {
  localStorage.setItem('access_token', access_token)
}

export const clearLocalStorage = () => {
  localStorage.removeItem('access_token')
  localStorage.removeItem('profile')
  localStorage.removeItem('refresh_token')
  const clearLSEvent = new Event('clearLocalStorage')
  localStorageEventTarget.dispatchEvent(clearLSEvent)
}

export const getAccessTokenFromLS = () => localStorage.getItem('access_token') || ''

export const getRefreshTokenFromLS = () => localStorage.getItem('refresh_token') || ''

export const getProfileFormLS = () => {
  const result = localStorage.getItem('profile')
  return result ? JSON.parse(result) : null
}

export const setProfileFromLS = (profile: User) => {
  localStorage.setItem('profile', JSON.stringify(profile))
}

export const removeAccessTokenFromLS = () => {
  localStorage.removeItem('access_token')
}
</file>

<file path="src/utils/http.ts">
import axios, { AxiosError, AxiosInstance, HttpStatusCode } from 'axios'
import configBase from '../constants/config'
import { clearLocalStorage, getAccessTokenFromLS, saveAccessTokenToLS, setProfileFromLS } from './auth'
import { toast } from 'sonner'
import path from '../constants/path'
class Http {
  instance: AxiosInstance
  private accessToken: string
  constructor() {
    this.accessToken = `Bearer ${getAccessTokenFromLS()}`
    this.instance = axios.create({
      baseURL: configBase.baseURL,
      timeout: 10000,
      headers: {
        Accept: 'application/json',
        'Content-Type': 'application/json'
      }
    })
    this.instance.interceptors.request.use(
      (config) => {
        if (this.accessToken && config.headers) {
          config.headers.authorization = this.accessToken
        }

        return config
      },
      (error) => {
        return Promise.reject(error)
      }
    )

    this.instance.interceptors.response.use(
      (response) => {
        const { url } = response.config
        if (url === path.register || url === path.login) {
          const data = response.data
          this.accessToken = data.data?.access_token

          saveAccessTokenToLS(this.accessToken)
          setProfileFromLS(data.data.user)
        } else if (url === '/logout') {
          this.accessToken = ''
          clearLocalStorage()
        }
        return response
      },
      function (error: AxiosError) {
        if (error.response?.status !== HttpStatusCode.UnprocessableEntity) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const data: any | undefined = error.response?.data
          const message = data.message || error.message
          toast.error(message)
        }
        if (error.response?.status === HttpStatusCode.Unauthorized) {
          clearLocalStorage()
        }
        return Promise.reject(error)
      }
    )
  }
}
const http = new Http().instance
export default http
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class', // Use class strategy instead of media queries
  theme: {
    extend: {
      colors: {
        background: 'var(--background)',
        foreground: 'var(--foreground)',
        card: 'var(--card)',
        'card-foreground': 'var(--card-foreground)',
        popover: 'var(--popover)',
        'popover-foreground': 'var(--popover-foreground)',
        primary: 'var(--primary)',
        'primary-foreground': 'var(--primary-foreground)',
        secondary: 'var(--secondary)',
        'secondary-foreground': 'var(--secondary-foreground)',
        muted: 'var(--muted)',
        'muted-foreground': 'var(--muted-foreground)',
        accent: 'var(--accent)',
        'accent-foreground': 'var(--accent-foreground)',
        destructive: 'var(--destructive)',
        border: 'var(--border)',
        input: 'var(--input)',
        ring: 'var(--ring)',
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
    },
  },
  plugins: [],
}
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.node.json"
    }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
  plugins: [
    react(),
    tailwindcss(),
  ],
})
</file>

<file path="src/apis/comic.api.ts">
import http from '../utils/http';
import { mapToComicCarousel, mapToComicDetail, ChapterDetail } from '../types/Comic.type';

// CDN URL for images
const cdnUrl = 'https://img.otruyenapi.com';

// New interfaces for API response
interface ChapterImageApi {
  image_page: number;
  image_file: string;
}

interface ChapterItemApi {
  _id: string;
  comic_name: string;
  chapter_name: string;
  chapter_title: string;
  chapter_path: string;
  chapter_image: ChapterImageApi[];
}

interface ChapterApiResponse {
  status: string;
  message: string;
  data: {
    domain_cdn: string;
    item: ChapterItemApi;
  };
}

// Helper function to map chapter detail API data
export const mapToChapterDetail = (apiChapter: ChapterItemApi, domainCdn: string): ChapterDetail => {
  // Generate a timestamp to ensure uniqueness even if the same chapter is fetched multiple times
  const timestamp = Date.now();
  // Generate a unique string ID for this chapter
  const chapterUniqueId = `${apiChapter._id}-${apiChapter.chapter_name}-${timestamp}`;
  
  // Ensure images have truly unique identifiers
  const uniqueImages = apiChapter.chapter_image.map((img, index) => ({
    page: img.image_page,
    imageUrl: `${domainCdn}/${apiChapter.chapter_path}/${img.image_file}`,
    uniqueIndex: index, // Keep for backward compatibility
    uniqueId: `${chapterUniqueId}-img-${index}` // Guaranteed to be unique across all requests
  }));

  return {
    chapterName: apiChapter.chapter_name,
    chapterTitle: apiChapter.chapter_title || '',
    images: uniqueImages
  };
};

/**
 * API functions for interacting with comic endpoints
 */
const comicApi = {
  /**
   * Fetches comics for the home page
   * @returns Promise with comic data for home page
   */
  getHome: () => {
    return http.get<any>('/home').then(response => {
      const apiData = response.data.data.items;
      return apiData.map((item: any) => mapToComicCarousel(item, cdnUrl));
    });
  },

  /**
   * Fetches comics by genre and page number
   * @param genre - genre slug to filter comics
   * @param page - page number for pagination
   * @returns Promise with comic data for the specified genre
   */
  getByGenre: (genre: string, page: number = 1) => {
    return http.get<any>(`/the-loai/${genre}?page=${page}`).then(response => {
      const apiData = response.data.data.items;
      return apiData.map((item: any) => mapToComicCarousel(item, cdnUrl));
    });
  },

  /**
   * Fetches comics by category with pagination
   * @param categorySlug - category slug to filter comics
   * @param page - page number for pagination
   * @returns Promise with comic data for the specified category
   */
  getCategory: (categorySlug: string, page: number = 1) => {
    return http.get<any>(`/the-loai/${categorySlug}?page=${page}`).then(response => {
      const apiData = response.data.data.items;
      return apiData.map((item: any) => mapToComicCarousel(item, cdnUrl));
    });
  },

  /**
   * Fetches new comics with pagination
   * @param page - page number for pagination
   * @returns Promise with comic data for new comics (24 comics per page)
   */
  getNew: (page: number = 1) => {
    return http.get<any>(`/danh-sach/truyen-moi?page=${page}`).then(response => {
      const apiData = response.data.data.items;
      return apiData.map((item: any) => mapToComicCarousel(item, cdnUrl));
    });
  },

  /**
   * Searches for comics by keyword with pagination
   * @param keyword - search term to find comics
   * @param page - page number for pagination
   * @returns Promise with comic data matching the search term
   */
  search: (keyword: string, page: number = 1) => {
    return http.get<any>(`/tim-kiem?keyword=${encodeURIComponent(keyword)}&page=${page}`).then(response => {
      const apiData = response.data.data.items;
      return apiData.map((item: any) => mapToComicCarousel(item, cdnUrl));
    });
  },

  /**
   * Fetches detailed information for a specific comic
   * @param slug - comic slug to fetch details for
   * @returns Promise with detailed comic data
   */
  getDetail: (slug: string) => {
    return http.get<any>(`/truyen-tranh/${slug}`).then(response => {
      const { item, APP_DOMAIN_CDN_IMAGE } = response.data.data;
      // Use the CDN URL from the API response if available, otherwise fallback to the default
      return mapToComicDetail(item, APP_DOMAIN_CDN_IMAGE || cdnUrl);
    });
  },

  /**
   * Fetches detailed information for a specific chapter
   * @param chapterUrl - full URL to fetch chapter details
   * @returns Promise with detailed chapter data including images
   */
  getChapterDetail: (chapterUrl: string) => {
    return http.get<ChapterApiResponse>(chapterUrl).then(response => {
      const { item, domain_cdn } = response.data.data;
      return mapToChapterDetail(item, domain_cdn);
    });
  }
};

export default comicApi;
</file>

<file path="src/components/CarouselItem.tsx">
import { motion, MotionValue, useTransform } from "framer-motion";
import { ComicCarousel } from "../types/Comic.type";

interface CarouselItemProps {
  comic: ComicCarousel;
  index: number;
  x: MotionValue<number>;
  currentIndex: number;
  trackItemOffset: number;
  itemWidth: number;
  round: boolean;
  effectiveTransition: any;
}

export default function CarouselItem({
  comic,
  index,
  x,

  trackItemOffset,
  itemWidth,
  round,
  effectiveTransition
}: CarouselItemProps) {
  const range = [
    -(index + 1) * trackItemOffset,
    -index * trackItemOffset,
    -(index - 1) * trackItemOffset,
  ];
  const outputRange = [90, 0, -90];
  const rotateY = useTransform(x, range, outputRange, { clamp: false });

  return (
    <motion.div
      className={`relative shrink-0 flex flex-col ${round
        ? "items-center justify-center text-center bg-background/90"
        : "items-start justify-between bg-card rounded-[12px]"
        } overflow-hidden cursor-grab active:cursor-grabbing shadow-lg`}
      style={{
        width: itemWidth,
        height: round ? itemWidth : "auto",
        minHeight: "400px",
        rotateY: rotateY,
        ...(round && { borderRadius: "50%" }),
      }}
      transition={effectiveTransition}
    >
      <div 
        className="w-full h-[280px] bg-cover bg-center" 
        style={{ 
          backgroundImage: `url(${comic?.thumbnail || ''})` 
        }}
      />
      <div className="p-5">
        <div className="mb-2 font-black text-2xl text-card-foreground">
          {comic?.title || ''}
        </div>
        <p className="text-base text-card-foreground/80">
          {comic?.origin_name && comic.origin_name.length > 0 ? comic.origin_name[0] : ''}
        </p>
      </div>
    </motion.div>
  );
}
</file>

<file path="src/components/layout/Header.tsx">
import { Link, useNavigate } from 'react-router-dom'
import { Button } from '../../components/ui/button'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger
} from '../../components/ui/dropdown-menu'
import { ModeToggle } from '../../components/mode-toggle'
import { Input } from '../../components/ui/input'
import path from '../../constants/path'
import { Search, Menu, X, ArrowLeft, Bookmark, BookOpenCheck, ChevronDown } from 'lucide-react'
import { useEffect, useState } from 'react'
import { Avatar, AvatarFallback, AvatarImage } from '../../components/ui/avatar'
import useAuthStore from '../../store/authStore'
import categoryApi from '../../apis/category.api'
import { Category } from '../../types/Category.type'
import comicApi from '../../apis/comic.api'
import { ComicCarousel } from '../../types/Comic.type'
import useComicStore from '../../store/comicStore'
import { useDebounce } from '../../hooks/useDebounce'

const Header = () => {
  const { user, isAuthenticated, logout } = useAuthStore()
  const navigate = useNavigate()
  
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false)
  const [searchOpen, setSearchOpen] = useState(false)
  const [categories, setCategories] = useState<Category[]>([])
  const [searchInput, setSearchInput] = useState('')
  const [quickResults, setQuickResults] = useState<ComicCarousel[]>([])
  const [isSearching, setIsSearching] = useState(false)
  
  // Debounce the search input to avoid making too many API calls
  const debouncedSearch = useDebounce(searchInput, 500)
  
  // Use the search function from comic store
  const { fetchSearchResults } = useComicStore()

  useEffect(() => {
    const fetchCategories = async () => {
      try {
        const response = await categoryApi.getAll()
        setCategories(response.data.items)
      } catch (error) {
        console.error('Failed to fetch categories:', error)
      }
    }

    fetchCategories()
  }, [])
  
  // Fetch quick search results when debounced search value changes
  useEffect(() => {
    const fetchQuickSearchResults = async () => {
      if (!debouncedSearch.trim()) {
        setQuickResults([])
        return
      }
      
      try {
        setIsSearching(true)
        const results = await comicApi.search(debouncedSearch)
        // Only take the first 5 results for quick preview
        setQuickResults(results.slice(0, 5))
      } catch (error) {
        console.error('Failed to fetch search results:', error)
      } finally {
        setIsSearching(false)
      }
    }
    
    fetchQuickSearchResults()
  }, [debouncedSearch])

  const handleLogout = () => {
    logout()
    // Additional logic if needed
  }
  
  const handleSearchInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchInput(e.target.value)
  }
  
  const handleSearchSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (searchInput.trim()) {
      // Fetch full search results and navigate to search page
      fetchSearchResults(searchInput)
      navigate(`/search?keyword=${encodeURIComponent(searchInput)}`)
      setSearchOpen(false)
      setSearchInput('')
    }
  }
  
  const handleComicClick = (slug: string) => {
    navigate(`/truyen-tranh/${slug}`)
    setSearchOpen(false)
    setSearchInput('')
  }

  if (searchOpen) {
    return (
      <header className='sticky top-0 z-50 w-full border-b bg-background'>
        <form onSubmit={handleSearchSubmit} className='container h-16'>
          <div className='flex h-full items-center px-4 sm:px-6 lg:px-8'>
            <Button 
              type="button"
              variant='ghost' 
              size='icon' 
              onClick={() => {
                setSearchOpen(false)
                setSearchInput('')
              }}
            >
              <ArrowLeft className='h-5 w-5' />
            </Button>
            <div className='flex-1 mx-2 relative'>
              <Input 
                value={searchInput}
                onChange={handleSearchInputChange}
                placeholder="Nhập tên truyện để tìm..." 
                className="w-full" 
                autoFocus
              />
              
              {/* Quick search results dropdown */}
              {searchInput.trim() && (
                <div className='absolute top-full left-0 right-0 mt-1 bg-background border rounded-md shadow-lg z-50 max-h-80 overflow-y-auto'>
                  {isSearching ? (
                    <div className='p-4 text-center'>Đang tìm kiếm...</div>
                  ) : quickResults.length > 0 ? (
                    <>
                      {quickResults.map(comic => (
                        <div 
                          key={comic.id} 
                          className='p-2 hover:bg-accent flex items-center cursor-pointer'
                          onClick={() => handleComicClick(comic.slug)}
                        >
                          <div className='h-12 w-12 mr-3 overflow-hidden rounded'>
                            <img 
                              src={comic.thumbnail || 'https://placehold.co/48x48'} 
                              alt={comic.title} 
                              className='h-full w-full object-cover'
                            />
                          </div>
                          <div>
                            <div className='font-medium text-sm'>{comic.title}</div>
                            <div className='text-xs text-muted-foreground'>
                              Chap {comic.latestChapter?.chapterName || "N/A"}
                            </div>
                          </div>
                        </div>
                      ))}
                      <div 
                        className='p-2 text-center text-sm text-blue-600 hover:bg-accent cursor-pointer font-medium'
                        onClick={handleSearchSubmit}
                      >
                        Xem tất cả kết quả
                      </div>
                    </>
                  ) : (
                    <div className='p-4 text-center'>Không tìm thấy kết quả</div>
                  )}
                </div>
              )}
            </div>
            <Button type="submit" variant='ghost' size='icon'>
              <Search className='h-5 w-5' />
            </Button>
          </div>
        </form>
      </header>
    )
  }

  return (
    <header className='sticky top-0 z-50 w-full border-b bg-background'>
      <div className='container flex h-16 items-center px-4 sm:px-6 lg:px-8'>
        <div className='flex items-center md:w-1/3'>
          <div className='md:hidden'>
            <Button variant='ghost' size='icon' onClick={() => setMobileMenuOpen(!mobileMenuOpen)}>
              {mobileMenuOpen ? <X className='h-6 w-6' /> : <Menu className='h-6 w-6' />}
            </Button>
          </div>
          <div className='hidden md:flex md:items-center md:space-x-6'>
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" className="flex items-center text-sm font-medium transition-colors hover:text-primary px-3 py-2">
                  Thể loại
                  <ChevronDown className="ml-1 h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="start" className="w-[600px] p-4">
                <div className="grid grid-cols-5 gap-3">
                  {categories.length > 0 ? (
                    categories.map((category) => (
                      <Link 
                        key={category._id}
                        to={`/the-loai/${category.slug}`} 
                        className="px-3 py-2 rounded-md hover:bg-accent transition-colors text-sm"
                      >
                        {category.name}
                      </Link>
                    ))
                  ) : (
                    <div className="col-span-3 text-center py-2 text-muted-foreground">Loading categories...</div>
                  )}
                </div>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>

        <div className='flex flex-1 items-center justify-center'>
          <Link to={path.home} className='flex items-center space-x-2'>
            <BookOpenCheck  className='h-6 w-6 text-primary' />
            <span className='font-bold sm:inline-block'>NON TRUYỆN</span>
          </Link>
        </div>

        <div className='flex items-center md:w-1/3 justify-end gap-2'>

          <ModeToggle />
          
          <Button variant='ghost' size='icon' onClick={() => setSearchOpen(true)}>
            <Search className='h-5 w-5' />
          </Button>

          <Link to={path.orders}>
            <Button variant='ghost' size='icon'>
              <Bookmark className='h-5 w-5' />
            </Button>
          </Link>

          {isAuthenticated && user ? (
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant='ghost' className='relative h-8 w-8 rounded-full'>
                  <Avatar className='h-8 w-8'>
                    <AvatarImage src={user.avatar || ""} alt={user.name || ""} />
                    <AvatarFallback>{user.name ? user.name.charAt(0).toUpperCase() : 'U'}</AvatarFallback>
                  </Avatar>
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent className='w-56' align='end' forceMount>
                <div className='flex items-center justify-start gap-2 p-2'>
                  <div className='flex flex-col space-y-1 leading-none'>
                    <p className='font-medium'>{user.name || 'User'}</p>
                    <p className='text-xs text-muted-foreground'>{user.email || ''}</p>
                  </div>
                </div>
                <DropdownMenuSeparator />
                <DropdownMenuItem onClick={() => navigate(path.profile)}>Profile</DropdownMenuItem>
                <DropdownMenuItem onClick={() => navigate(path.orders)}>My Orders</DropdownMenuItem>
                <DropdownMenuSeparator />
                <DropdownMenuItem onClick={handleLogout}>Log out</DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          ) : (
            <div className='flex items-center space-x-2'>
              <Button variant='destructive' onClick={() => navigate(path.login)}>
                Đăng Nhập
              </Button>
              <Button onClick={() => navigate(path.register)}>Đăng Ký</Button>
            </div>
          )}
        </div>
      </div>

      {/* Mobile Menu */}
      {mobileMenuOpen && (
        <div className='md:hidden'>
          <div className='space-y-2 px-4 py-3'>
            <div className="rounded-md px-3 py-2 text-base font-medium hover:bg-accent">
              <div className="font-medium mb-2">Thể loại</div>
              <div className="grid grid-cols-2 gap-1 pl-3">
                {categories.length > 0 ? (
                  categories.map((category) => (
                    <Link
                      key={category._id}
                      to={`/the-loai/${category.slug}`}
                      className="py-1 text-sm hover:text-primary"
                      onClick={() => setMobileMenuOpen(false)}
                    >
                      {category.name}
                    </Link>
                  ))
                ) : (
                  <div className="text-sm text-muted-foreground">Loading categories...</div>
                )}
              </div>
            </div>
            <Link
              to={path.healthAZ}
              className='block rounded-md px-3 py-2 text-base font-medium hover:bg-accent'
              onClick={() => setMobileMenuOpen(false)}
            >
              Health A-Z
            </Link>
            <Link
              to={path.medicines}
              className='block rounded-md px-3 py-2 text-base font-medium hover:bg-accent'
              onClick={() => setMobileMenuOpen(false)}
            >
              Drugs & Supplements
            </Link>
            <Link
              to={path.doctors}
              className='block rounded-md px-3 py-2 text-base font-medium hover:bg-accent'
              onClick={() => setMobileMenuOpen(false)}
            >
              Find a Doctor
            </Link>
            <Link
              to={path.feedback}
              className='block rounded-md px-3 py-2 text-base font-medium hover:bg-accent'
              onClick={() => setMobileMenuOpen(false)}
            >
              Feedback
            </Link>

            <div className='border-t pt-4'>
              {isAuthenticated && user ? (
                <>
                  <div className='flex items-center px-3 py-2'>
                    <Avatar className='h-8 w-8 mr-3'>
                      <AvatarImage src={user.avatar || ""} alt={user.name || ""} />
                      <AvatarFallback>{user.name ? user.name.charAt(0).toUpperCase() : 'U'}</AvatarFallback>
                    </Avatar>
                    <div>
                      <p className='font-medium'>{user.name || 'User'}</p>
                      <p className='text-xs text-muted-foreground'>{user.email || ''}</p>
                    </div>
                  </div>
                  <Link
                    to={path.profile}
                    className='block rounded-md px-3 py-2 text-base font-medium hover:bg-accent'
                    onClick={() => setMobileMenuOpen(false)}
                  >
                    Profile
                  </Link>
                  <Link
                    to={path.orders}
                    className='block rounded-md px-3 py-2 text-base font-medium hover:bg-accent'
                    onClick={() => setMobileMenuOpen(false)}
                  >
                    My Orders
                  </Link>
                  <button
                    className='block w-full text-left rounded-md px-3 py-2 text-base font-medium hover:bg-accent'
                    onClick={() => {
                      handleLogout()
                      setMobileMenuOpen(false)
                    }}
                  >
                    Log out
                  </button>
                </>
              ) : (
                <>
                  <Link
                    to={path.login}
                    className='block rounded-md px-3 py-2 text-base font-medium hover:bg-accent'
                    onClick={() => setMobileMenuOpen(false)}
                  >
                    Đăng nhập
                  </Link>
                  <Link
                    to={path.register}
                    className='block rounded-md px-3 py-2 text-base font-medium hover:bg-accent'
                    onClick={() => setMobileMenuOpen(false)}
                  >
                    Đăng ký
                  </Link>
                </>
              )}
            </div>
          </div>
        </div>
      )}
    </header>
  )
}

export default Header
</file>

<file path="src/components/TiltedCard.tsx">
import type { SpringOptions } from "framer-motion";
import { useRef, useState } from "react";
import { motion, useMotionValue, useSpring } from "framer-motion";
import { useTheme } from "./theme-provider";

interface TiltedCardProps {
  imageSrc: React.ComponentProps<"img">["src"];
  altText?: string;
  captionText?: string;
  containerHeight?: React.CSSProperties["height"];
  containerWidth?: React.CSSProperties["width"];
  imageHeight?: React.CSSProperties["height"];
  imageWidth?: React.CSSProperties["width"];
  scaleOnHover?: number;
  rotateAmplitude?: number;
  showMobileWarning?: boolean;
  showTooltip?: boolean;
  overlayContent?: React.ReactNode;
  displayOverlayContent?: boolean;
  enableRainbowEffect?: boolean; // New prop to toggle rainbow effect
}

const springValues: SpringOptions = {
  damping: 30,
  stiffness: 100,
  mass: 2,
};

export default function TiltedCard({
  imageSrc,
  altText = "Tilted card image",
  captionText = "",
  containerHeight = "300px",
  containerWidth = "100%",
  imageHeight = "300px",
  imageWidth = "300px",
  scaleOnHover = 1.1,
  rotateAmplitude = 14,
  showMobileWarning = true,
  showTooltip = true,
  overlayContent = null,
  displayOverlayContent = false,
  enableRainbowEffect = true, // Enabled by default
}: TiltedCardProps) {
  const {  } = useTheme();
  const ref = useRef<HTMLElement>(null);
  const x = useMotionValue(0);
  const y = useMotionValue(0);
  const rotateX = useSpring(useMotionValue(0), springValues);
  const rotateY = useSpring(useMotionValue(0), springValues);
  const scale = useSpring(1, springValues);
  const opacity = useSpring(0);
  const rotateFigcaption = useSpring(0, {
    stiffness: 350,
    damping: 30,
    mass: 1,
  });

  // Rainbow effect values
  const rainbowOpacity = useSpring(0, springValues);
  const rainbowX = useSpring(0, springValues);
  const rainbowY = useSpring(0, springValues);

  const [lastY, setLastY] = useState(0);

  function handleMouse(e: React.MouseEvent<HTMLElement>) {
    if (!ref.current) return;

    const rect = ref.current.getBoundingClientRect();
    const offsetX = e.clientX - rect.left - rect.width / 2;
    const offsetY = e.clientY - rect.top - rect.height / 2;

    const rotationX = (offsetY / (rect.height / 2)) * -rotateAmplitude;
    const rotationY = (offsetX / (rect.width / 2)) * rotateAmplitude;

    rotateX.set(rotationX);
    rotateY.set(rotationY);

    x.set(e.clientX - rect.left);
    y.set(e.clientY - rect.top);

    // Update rainbow effect position
    if (enableRainbowEffect) {
      const normalizedX = offsetX / (rect.width / 2);
      const normalizedY = offsetY / (rect.height / 2);
      rainbowX.set(normalizedX * 20); // Small movement for smooth effect
      rainbowY.set(normalizedY * 20);
    }

    const velocityY = offsetY - lastY;
    rotateFigcaption.set(-velocityY * 0.6);
    setLastY(offsetY);
  }

  function handleMouseEnter() {
    scale.set(scaleOnHover);
    opacity.set(1);
    if (enableRainbowEffect) {
      rainbowOpacity.set(0.6); // Show rainbow effect
    }
  }

  function handleMouseLeave() {
    opacity.set(0);
    scale.set(1);
    rotateX.set(0);
    rotateY.set(0);
    rotateFigcaption.set(0);
    if (enableRainbowEffect) {
      rainbowOpacity.set(0); // Hide rainbow effect
      rainbowX.set(0);
      rainbowY.set(0);
    }
  }

  return (
    <figure
      ref={ref}
      className="relative w-full h-full [perspective:800px] flex flex-col items-center justify-center"
      style={{
        height: containerHeight,
        width: containerWidth,
      }}
      onMouseMove={handleMouse}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      {showMobileWarning && (
        <div className="absolute top-4 text-center text-sm block sm:hidden dark:text-gray-200">
          This effect is not optimized for mobile. Check on desktop.
        </div>
      )}

      <motion.div
        className="relative [transform-style:preserve-3d]"
        style={{
          width: imageWidth,
          height: imageHeight,
          rotateX,
          rotateY,
          scale,
        }}
      >
        <motion.img
          src={imageSrc}
          alt={altText}
          className="absolute top-0 left-0 object-cover rounded-[15px] will-change-transform [transform:translateZ(0)]"
          style={{
            width: imageWidth,
            height: imageHeight,
          }}
        />

        {enableRainbowEffect && (
          <motion.div
            className="absolute top-0 left-0 w-full h-full rounded-[15px] z-[1] will-change-transform [transform:translateZ(10px)] overflow-visible pointer-events-none"
            style={{
              opacity: rainbowOpacity,
              x: rainbowX,
              y: rainbowY,
            }}
          >
            <div
              className="absolute inset-[-4px] rounded-[17px]"
              style={{
                background: "linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #8f00ff)",
                backgroundSize: "400% 400%",
                boxShadow: "0 0 8px 2px rgba(255, 255, 255, 0.6)",
                animation: "rainbow-shine 5s ease infinite",
                border: "none",
              }}
            />
            <div
              className="absolute inset-[-2px] rounded-[16px]"
              style={{
                background: "transparent",
                boxShadow: "inset 0 0 0 4px rgba(255, 255, 255, 0)",
                border: "2px solid transparent",
                mask: "radial-gradient(circle at center, transparent 96%, black 97%)",
                WebkitMask: "radial-gradient(circle at center, transparent 96%, black 97%)",
              }}
            />
          </motion.div>
        )}

        {displayOverlayContent && overlayContent && (
          <motion.div className="absolute top-0 left-0 z-[2] will-change-transform [transform:translateZ(30px)]">
            {overlayContent}
          </motion.div>
        )}
      </motion.div>

      {showTooltip && (
        <motion.figcaption
          className="pointer-events-none absolute left-0 top-0 rounded-[4px] bg-white dark:bg-gray-800 px-[10px] py-[4px] text-[10px] text-[#2d2d2d] dark:text-white opacity-0 z-[3] hidden sm:block"
          style={{
            x,
            y,
            opacity,
            rotate: rotateFigcaption,
          }}
        >
          {captionText}
        </motion.figcaption>
      )}

      <style>
        {`
          @keyframes rainbow-shine {
            0% {
              background-position: 0% 50%;
            }
            50% {
              background-position: 100% 50%;
            }
            100% {
              background-position: 0% 50%;
            }
          }
        `}
      </style>
    </figure>
  );
}
</file>

<file path="src/pages/Category/CategoryPage.tsx">
import { useState, useEffect } from "react";
import { useNavigate, useParams } from "react-router-dom";
import TiltedCard from "../../components/TiltedCard";
import comicApi from "../../apis/comic.api";
import { ComicCarousel } from "../../types/Comic.type";
import { ChevronLeft, ChevronRight, BookOpen } from "lucide-react";
import categoryApi from "../../apis/category.api";
import { Category } from "../../types/Category.type";

const CategoryPage = () => {
  const navigate = useNavigate();
  const { slug } = useParams<{ slug: string }>();
  const [comics, setComics] = useState<ComicCarousel[]>([]);
  const [category, setCategory] = useState<Category | null>(null);
  const [currentPage, setCurrentPage] = useState(1);
  const [isLoading, setIsLoading] = useState(false);
  const [totalPages, setTotalPages] = useState(1);

  // Navigate to comic detail page when a comic is clicked
  const handleComicClick = (slug: string) => {
    navigate(`/truyen-tranh/${slug}`);
  };

  // Fetch category info
  useEffect(() => {
    const fetchCategoryInfo = async () => {
      try {
        const response = await categoryApi.getAll();
        const categories = response.data.items;
        const foundCategory = categories.find(cat => cat.slug === slug);
        if (foundCategory) {
          setCategory(foundCategory);
        }
      } catch (error) {
        console.error("Failed to fetch category info:", error);
      }
    };

    if (slug) {
      fetchCategoryInfo();
    }
  }, [slug]);

  // Fetch comics for this category
  useEffect(() => {
    const fetchComics = async () => {
      if (!slug) return;
      
      try {
        setIsLoading(true);
        const data = await comicApi.getCategory(slug, currentPage);
        setComics(data);
        // Assuming the API doesn't return total pages, we estimate it
        setTotalPages(Math.max(totalPages, currentPage + 1));
      } catch (error) {
        console.error("Failed to fetch comics:", error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchComics();
  }, [slug, currentPage, totalPages]);

  const handlePageChange = (page: number) => {
    if (page >= 1 && page <= totalPages) {
      setCurrentPage(page);
      window.scrollTo({ top: 0, behavior: "smooth" });
    }
  };

  const getTimeAgo = (updatedAt: string) => {
    const now = new Date();
    const updated = new Date(updatedAt);
    const diffMs = now.getTime() - updated.getTime();

    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);

    if (diffDays > 0) return `${diffDays} ngày trước`;
    if (diffHours > 0) return `${diffHours} giờ trước`;
    return `${diffMins} phút trước`;
  };

  const renderPagination = () => {
    const pages = [];
    const maxPagesToShow = 5;

    let startPage = Math.max(1, currentPage - Math.floor(maxPagesToShow / 2));
    let endPage = Math.min(totalPages, startPage + maxPagesToShow - 1);

    if (endPage - startPage + 1 < maxPagesToShow) {
      startPage = Math.max(1, endPage - maxPagesToShow + 1);
    }

    for (let i = startPage; i <= endPage; i++) {
      pages.push(
        <button
          key={i}
          onClick={() => handlePageChange(i)}
          className={`px-3 py-1 mx-1 rounded ${
            currentPage === i
              ? "bg-blue-600 text-white"
              : "bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-white"
          }`}
        >
          {i}
        </button>
      );
    }

    return (
      <div className="flex items-center justify-center mt-8">
        <button
          onClick={() => handlePageChange(currentPage - 1)}
          disabled={currentPage === 1 || isLoading}
          className="p-2 mr-2 rounded bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 disabled:opacity-50 dark:text-white"
          aria-label="Previous page"
        >
          <ChevronLeft size={18} />
        </button>

        {pages}

        <button
          onClick={() => handlePageChange(currentPage + 1)}
          disabled={currentPage === totalPages || isLoading}
          className="p-2 ml-2 rounded bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 disabled:opacity-50 dark:text-white"
          aria-label="Next page"
        >
          <ChevronRight size={18} />
        </button>
      </div>
    );
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-2xl font-bold mb-6 dark:text-white">
        {category ? category.name : 'Loading category...'}
      </h1>

      {isLoading ? (
        <div className="flex justify-center items-center py-20">
          <p className="text-lg text-gray-600 dark:text-gray-400">Loading comics...</p>
        </div>
      ) : (
        <>
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4">
            {comics.map((comic, index) => (
              <div 
                key={comic.id || index} 
                className="flex flex-col cursor-pointer transition-transform hover:scale-105" 
                onClick={() => handleComicClick(comic.slug)}
              >
                <TiltedCard
                  imageSrc={
                    comic.thumbnail ||
                    "https://picsum.photos/seed/placeholder/800/600"
                  }
                  altText={comic.title || "Comic image"}
                  captionText=""
                  containerHeight="240px"
                  containerWidth="100%"
                  imageHeight="240px"
                  imageWidth="160px"
                  scaleOnHover={1.1}
                  rotateAmplitude={14}
                  showMobileWarning={true}
                  showTooltip={true}
                  overlayContent={
                    <div className="text-white text-xs p-1 bg-black bg-opacity-70">
                      {getTimeAgo(comic.updatedAt || new Date().toISOString())}
                    </div>
                  }
                  displayOverlayContent={true}
                />
                <div className="mt-2">
                  <h3 className="font-semibold text-sm truncate text-gray-800 dark:text-gray-100">
                    {comic.title}
                  </h3>
                  <div className="flex items-center mt-1 justify-center">
                    <BookOpen
                      size={14}
                      className="text-blue-600 dark:text-blue-400 mr-1 transition-colors duration-200"
                    />
                    <p className="text-xs font-medium text-gray-700 dark:text-gray-300 transition-colors duration-200">
                      Chap {comic.latestChapter?.chapterName || "Chưa có chapter"}
                    </p>
                  </div>
                </div>
              </div>
            ))}
          </div>

          {comics.length === 0 && !isLoading ? (
            <div className="text-center py-20">
              <p className="text-lg text-gray-600 dark:text-gray-400">Không tìm thấy truyện trong thể loại này.</p>
            </div>
          ) : null}

          {comics.length > 0 && renderPagination()}
        </>
      )}
    </div>
  );
};

export default CategoryPage;
</file>

<file path="src/pages/ComicDetail/ComicDetail.tsx">
import  { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import SpotlightCard from '../../components/SpotlightCard';
import { Comic } from '../../types/Comic.type';
import comicApi from '../../apis/comic.api';

const ComicDetail = () => {
  const { slug } = useParams<{ slug: string }>();
  const [comic, setComic] = useState<Comic | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [currentPage, setCurrentPage] = useState<number>(1);
  const chaptersPerPage = 50;

  useEffect(() => {
    const fetchComicDetail = async () => {
      if (!slug) return;
      
      try {
        setLoading(true);
        const data = await comicApi.getDetail(slug);
        setComic(data);
      } catch (err) {
        setError('Failed to load comic details');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    fetchComicDetail();
  }, [slug]);

  if (loading) {
    return (
      <div className="flex items-center justify-center h-[600px]">
        <div className="text-xl">Loading comic details...</div>
      </div>
    );
  }

  if (error || !comic) {
    return (
      <div className="flex flex-col mt-40 items-center justify-center h-[600px] space-y-4">
        <div className="text-xl text-red-500">{error || 'Comic not found'}</div>
        <Link 
          to="/" 
          className="px-4 py-2 bg-neutral-800 hover:bg-neutral-700 rounded-md transition-colors"
          tabIndex={0}
          aria-label="Return to home page"
        >
          Return Home
        </Link>
      </div>
    );
  }

  // Get all chapters across all servers
  const allChapters = comic.chapters.flatMap(server => server.chapters);
  
  // Get first and latest chapter
  const firstChapter = allChapters.length > 0 ? 
    allChapters[allChapters.length - 1] : null;
  const latestChapter = allChapters.length > 0 ? 
    allChapters[0] : null;
  
  // Calculate total pages
  const totalChapters = allChapters.length;
  const totalPages = Math.ceil(totalChapters / chaptersPerPage);
  
  // Get current page chapters
  const startIndex = (currentPage - 1) * chaptersPerPage;
  const endIndex = Math.min(startIndex + chaptersPerPage, totalChapters);
  const currentChapters = allChapters.slice(startIndex, endIndex);
  
  // Handle page changes
  const handlePageChange = (page: number) => {
    setCurrentPage(page);
    window.scrollTo(0, document.getElementById('chapters-section')?.offsetTop || 0);
  };

  return (
    <div className="flex flex-col pt-5 px-4 pb-16 space-y-8">
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        {/* Comic Image with SpotlightCard */}
        <div className="md:col-span-1">
          <SpotlightCard className="h-full">
            <img 
              src={comic.thumbnail} 
              alt={comic.title} 
              className="w-full h-auto rounded-xl object-cover"
            />
          </SpotlightCard>
        </div>
        
        {/* Comic Details */}
        <div className="md:col-span-2 flex flex-col space-y-4">
          <h1 className="text-3xl font-bold">{comic.title}</h1>
          
          {/* Origin Name */}
          {comic.origin_name && comic.origin_name.length > 0 && (
            <div className="text-neutral-400 text-lg italic">
              {comic.origin_name.join(' / ')}
            </div>
          )}
          
          {/* Authors/Directors */}
          {comic.authors && comic.authors.length > 0 && (
            <div className="flex flex-wrap items-center gap-2">
              <span className="text-neutral-400">Author:</span>
              <span className="font-medium">{comic.authors.join(', ')}</span>
            </div>
          )}
          
          {/* Status */}
          <div className="flex items-center gap-2">
            <span className="text-neutral-400">Status:</span>
            <span className={`font-medium ${comic.status === 'ongoing' ? 'text-green-400' : 'text-blue-400'}`}>
              {comic.status === 'ongoing' ? 'Ongoing' : 'Completed'}
            </span>
          </div>
          
          {/* Genres/Categories */}
          <div className="flex flex-wrap gap-2 mt-2">
            {comic.genres.map((genre, index) => (
              <Link 
                key={index}
                to={`/the-loai/${genre.toLowerCase().replace(/\s+/g, '-')}`}
                className="px-3 py-1 bg-secondary hover:bg-secondary/80 text-secondary-foreground rounded-full text-sm transition-colors"
                tabIndex={0}
                aria-label={`View ${genre} comics`}
              >
                {genre}
              </Link>
            ))}
          </div>
          
          {/* Description */}
          {comic.content && (
            <div className="mt-4">
              <h3 className="text-xl font-semibold mb-2">Description</h3>
              <div 
                className="text-neutral-300 text-sm" 
                dangerouslySetInnerHTML={{ __html: comic.content }}
              />
            </div>
          )}
          
          {/* Navigation Buttons */}
          <div className="flex flex-wrap gap-3 mt-4">

          {latestChapter && (
              <Link
                to={`/truyen-tranh/${comic.slug}/chapter/${latestChapter.name}`}
                className="px-4 py-2 bg-green-600 hover:bg-green-700 dark:text-white text-white rounded-md transition-colors"
                tabIndex={0}
                aria-label="Read latest chapter"
              >
                 Đọc từ đầu
               
              </Link>
            )}

            {firstChapter && (
              <Link
                to={`/truyen-tranh/${comic.slug}/chapter/${firstChapter.name}`}
                className="px-4 py-2 bg-primary hover:bg-primary/90 text-primary-foreground rounded-md transition-colors"
                tabIndex={0}
                aria-label="Read from the beginning"
              >
                Đọc tập mới nhất
              </Link>
            )}
            
         
            
            <button
              className="px-4 py-2 bg-purple-600 hover:bg-purple-700 dark:text-white text-white rounded-md transition-colors"
              tabIndex={0}
              aria-label="Continue reading"
              disabled
            >
              Đọc tiếp
            </button>
            
            <button
              className="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 dark:text-white text-white rounded-md transition-colors"
              tabIndex={0}
              aria-label="Follow this comic"
              disabled
            >
              Theo dõi
            </button>
          </div>
        </div>
      </div>
      
      {/* Chapters List */}
      <div className="mt-8" id="chapters-section">
        <h2 className="text-2xl font-bold mb-4">Chapters</h2>
        
        {/* Chapter Pagination */}
        {totalPages > 1 && (
          <div className="flex flex-wrap gap-2 mb-4">
            <span className="flex items-center text-neutral-400 dark:text-neutral-400">Chapters:</span>
            {Array.from({ length: totalPages }, (_, i) => i + 1).map((page) => {
              const firstChapterIndex = (page - 1) * chaptersPerPage;
              const lastChapterIndex = Math.min(page * chaptersPerPage - 1, totalChapters - 1);
              const fromChapter = allChapters[lastChapterIndex]?.name || '';
              const toChapter = allChapters[firstChapterIndex]?.name || '';
              
              return (
                <button
                  key={page}
                  onClick={() => handlePageChange(page)}
                  className={`px-3 py-1 rounded-md ${
                    currentPage === page 
                      ? 'bg-primary text-primary-foreground dark:text-primary-foreground' 
                      : 'bg-secondary hover:bg-secondary/80 text-secondary-foreground dark:text-secondary-foreground'
                  }`}
                  tabIndex={0}
                >
                  {toChapter} - {fromChapter}
                </button>
              );
            })}
          </div>
        )}
        
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
          {currentChapters.map((chapter, index) => (
            <Link
              key={`chapter-${startIndex + index}`}
              to={`/truyen-tranh/${comic.slug}/chapter/${chapter.name}`}
              className="px-4 py-3 bg-secondary hover:bg-secondary/80 text-secondary-foreground rounded-md transition-colors flex items-center justify-between"
              tabIndex={0}
              aria-label={`Read chapter ${chapter.name}`}
            >
              <span className="font-medium">Chapter {chapter.name}</span>
              {chapter.title && <span className="text-muted-foreground text-sm truncate ml-2">{chapter.title}</span>}
            </Link>
          ))}
        </div>
        
       
      </div>
    </div>
  );
};

export default ComicDetail;
</file>

<file path="src/pages/HomePage/HomePage.tsx">
import  { useEffect } from 'react'
import CircularGallery from '../../components/CircularGallery'
import useComicStore from '../../store/comicStore'
import NewComic from '../NewComic';
import { useNavigate } from 'react-router-dom';

const HomePage = () => {
  const { homeComics, isLoadingHomeComics, fetchHomeComics } = useComicStore();
  const navigate = useNavigate();

  useEffect(() => {
    fetchHomeComics();
  }, [fetchHomeComics]);

  const truncateText = (text: string | undefined, maxLength: number = 20): string => {
    if (!text) return 'Comic';
    return text.length > maxLength ? `${text.substring(0, maxLength)}...` : text;
  };

  const galleryItems = homeComics.map(comic => ({
    image: comic.thumbnail || 'https://picsum.photos/seed/placeholder/800/600',
    text: truncateText(comic.title),
    slug: comic.slug,
  }));

  const handleItemClick = (index: number) => {
    const N = homeComics.length;
    if (N === 0) return;
    const selectedIndex = index % N;
    const selectedComic = homeComics[selectedIndex];
    if (selectedComic && selectedComic.slug) {
      navigate(`/truyen-tranh/${selectedComic.slug}`);
    }
  };

  if (isLoadingHomeComics) {
    return (
      <div className="flex items-center justify-center h-[600px]">
        <div className="text-xl">Loading comics...</div>
      </div>
    );
  }

  return (
    <div className="flex flex-col space-y-8 pb-16">
      <div className="h-[600px] relative">
        <CircularGallery 
          items={galleryItems} 
          bend={0.25} 
          borderRadius={0.05}
          font="bold 28px Quicksand"
          onItemClick={handleItemClick}
        />
       
      </div>

      <div className="relative">
        <NewComic/>
      </div>
    </div>
  )
}

export default HomePage
</file>

<file path="src/pages/NewComic/NewComic.tsx">
import  { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom"; // Add this import
import TiltedCard from "../../components/TiltedCard";
import comicApi from "../../apis/comic.api";
import { ComicCarousel } from "../../types/Comic.type";
import { ChevronLeft, ChevronRight, BookOpen } from "lucide-react";

const NewComic = () => {
  const navigate = useNavigate(); // Initialize navigate hook
  const [comics, setComics] = useState<ComicCarousel[]>([]);
  const [currentPage, setCurrentPage] = useState(1);
  const [isLoading, setIsLoading] = useState(false);
  const [totalPages, setTotalPages] = useState(1);

  // Navigate to comic detail page when a comic is clicked
  const handleComicClick = (slug: string) => {
    navigate(`/truyen-tranh/${slug}`);
  };

  const fetchComics = async (page: number) => {
    try {
      setIsLoading(true);
      const data = await comicApi.getNew(page);
      setComics(data);
      // Assuming the API doesn't return total pages, we estimate it
      // In a real application, the API should return this information
      setTotalPages(Math.max(totalPages, page + 1));
    } catch (error) {
      console.error("Failed to fetch comics:", error);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchComics(currentPage);
  }, [currentPage]);

  const handlePageChange = (page: number) => {
    if (page >= 1 && page <= totalPages) {
      setCurrentPage(page);
      window.scrollTo({ top: 650, behavior: "smooth" });
    }
  };

  const getTimeAgo = (updatedAt: string) => {
    const now = new Date();
    const updated = new Date(updatedAt);
    const diffMs = now.getTime() - updated.getTime();

    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);

    if (diffDays > 0) return `${diffDays} ngày trước`;
    if (diffHours > 0) return `${diffHours} giờ trước`;
    return `${diffMins} phút trước`;
  };

  const renderPagination = () => {
    const pages = [];
    const maxPagesToShow = 5;

    let startPage = Math.max(1, currentPage - Math.floor(maxPagesToShow / 2));
    let endPage = Math.min(totalPages, startPage + maxPagesToShow - 1);

    if (endPage - startPage + 1 < maxPagesToShow) {
      startPage = Math.max(1, endPage - maxPagesToShow + 1);
    }

    for (let i = startPage; i <= endPage; i++) {
      pages.push(
        <button
          key={i}
          onClick={() => handlePageChange(i)}
          className={`px-3 py-1 mx-1 rounded ${
            currentPage === i
              ? "bg-blue-600 text-white"
              : "bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-white"
          }`}
        >
          {i}
        </button>
      );
    }

    return (
      <div className="flex items-center justify-center mt-8">
        <button
          onClick={() => handlePageChange(currentPage - 1)}
          disabled={currentPage === 1 || isLoading}
          className="p-2 mr-2 rounded bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 disabled:opacity-50 dark:text-white"
          aria-label="Previous page"
        >
          <ChevronLeft size={18} />
        </button>

        {pages}

        <button
          onClick={() => handlePageChange(currentPage + 1)}
          disabled={currentPage === totalPages || isLoading}
          className="p-2 ml-2 rounded bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 disabled:opacity-50 dark:text-white"
          aria-label="Next page"
        >
          <ChevronRight size={18} />
        </button>
      </div>
    );
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-2xl font-bold mb-6 dark:text-white">Truyện Mới</h1>

      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4">
        {comics.map((comic, index) => (
          <div 
            key={comic.id || index} 
            className="flex flex-col cursor-pointer transition-transform hover:scale-105" 
            onClick={() => handleComicClick(comic.slug)}
          >
            <TiltedCard
              imageSrc={
                comic.thumbnail ||
                "https://picsum.photos/seed/placeholder/800/600"
              }
              altText={comic.title || "Comic image"}
              captionText=""
              containerHeight="240px"
              containerWidth="100%"
              imageHeight="240px"
              imageWidth="160px"
              scaleOnHover={1.1}
              rotateAmplitude={14}
              showMobileWarning={true}
              showTooltip={true}
              overlayContent={
                <div className="text-white text-xs p-1 bg-black bg-opacity-70">
                  {getTimeAgo(comic.updatedAt || new Date().toISOString())}
                </div>
              }
              displayOverlayContent={true}
            />
            <div className="mt-2">
              <h3 className="font-semibold text-sm truncate text-gray-800 dark:text-gray-100">
                {comic.title}
              </h3>
              <div className="flex items-center mt-1 justify-center">
                <BookOpen
                  size={14}
                  className="text-blue-600 dark:text-blue-400 mr-1 transition-colors duration-200"
                />
                <p className="text-xs font-medium text-gray-700 dark:text-gray-300 transition-colors duration-200">
                  Chap {comic.latestChapter?.chapterName || "Chưa có chapter"}
                </p>
              </div>
            </div>
          </div>
        ))}
      </div>

      {comics.length > 0 && renderPagination()}
    </div>
  );
};

export default NewComic;
</file>

<file path="src/pages/SearchPage/SearchPage.tsx">
import React, { useState, useEffect } from "react";
import { useNavigate, useSearchParams } from "react-router-dom";
import TiltedCard from "../../components/TiltedCard";
import { ChevronLeft, ChevronRight, BookOpen, Search } from "lucide-react";
import useComicStore from "../../store/comicStore";
import { Input } from "../../components/ui/input";
import { Button } from "../../components/ui/button";

const SearchPage = () => {
  const navigate = useNavigate();
  const [searchParams, setSearchParams] = useSearchParams();
  const keyword = searchParams.get("keyword") || "";
  const [searchInput, setSearchInput] = useState(keyword);
  
  const { 
    searchResults, 
    isLoadingSearch, 
    currentSearchPage, 
    fetchSearchResults
  } = useComicStore();
  
  const [totalPages] = useState(1);

  // Navigate to comic detail page when a comic is clicked
  const handleComicClick = (slug: string) => {
    navigate(`/truyen-tranh/${slug}`);
  };

  // Handle search form submission
  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    if (searchInput.trim()) {
      // Update the URL search parameter
      setSearchParams({ keyword: searchInput });
      // Fetch search results
      fetchSearchResults(searchInput);
    }
  };

  // Initial fetch and when URL params change
  useEffect(() => {
    if (keyword) {
      fetchSearchResults(keyword);
    }
  }, [keyword, fetchSearchResults]);

  // Update page title
  useEffect(() => {
    document.title = `Tìm kiếm: ${keyword} | Non Truyện`;
    return () => {
      document.title = "Non Truyện";
    };
  }, [keyword]);

  const handlePageChange = (page: number) => {
    if (page >= 1 && page <= totalPages && keyword) {
      fetchSearchResults(keyword, page);
      window.scrollTo({ top: 650, behavior: "smooth" });
    }
  };

  const getTimeAgo = (updatedAt: string) => {
    const now = new Date();
    const updated = new Date(updatedAt);
    const diffMs = now.getTime() - updated.getTime();

    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);

    if (diffDays > 0) return `${diffDays} ngày trước`;
    if (diffHours > 0) return `${diffHours} giờ trước`;
    return `${diffMins} phút trước`;
  };

  const renderPagination = () => {
    const pages = [];
    const maxPagesToShow = 5;

    let startPage = Math.max(1, currentSearchPage - Math.floor(maxPagesToShow / 2));
    let endPage = Math.min(totalPages, startPage + maxPagesToShow - 1);

    if (endPage - startPage + 1 < maxPagesToShow) {
      startPage = Math.max(1, endPage - maxPagesToShow + 1);
    }

    for (let i = startPage; i <= endPage; i++) {
      pages.push(
        <button
          key={i}
          onClick={() => handlePageChange(i)}
          className={`px-3 py-1 mx-1 rounded ${
            currentSearchPage === i
              ? "bg-blue-600 text-white"
              : "bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-white"
          }`}
        >
          {i}
        </button>
      );
    }

    return (
      <div className="flex items-center justify-center mt-8">
        <button
          onClick={() => handlePageChange(currentSearchPage - 1)}
          disabled={currentSearchPage === 1 || isLoadingSearch}
          className="p-2 mr-2 rounded bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 disabled:opacity-50 dark:text-white"
          aria-label="Previous page"
        >
          <ChevronLeft size={18} />
        </button>

        {pages}

        <button
          onClick={() => handlePageChange(currentSearchPage + 1)}
          disabled={currentSearchPage === totalPages || isLoadingSearch}
          className="p-2 ml-2 rounded bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 disabled:opacity-50 dark:text-white"
          aria-label="Next page"
        >
          <ChevronRight size={18} />
        </button>
      </div>
    );
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <h1 className="text-2xl font-bold mb-4 dark:text-white">
          {keyword ? `Kết quả tìm kiếm: ${keyword}` : 'Tìm kiếm truyện'}
        </h1>
        
        <form onSubmit={handleSearch} className="flex gap-2">
          <Input
            type="text"
            value={searchInput}
            onChange={(e) => setSearchInput(e.target.value)}
            placeholder="Nhập tên truyện để tìm kiếm..."
            className="flex-1"
          />
          <Button type="submit" disabled={isLoadingSearch}>
            <Search size={16} className="mr-2" />
            Tìm kiếm
          </Button>
        </form>
      </div>

      {isLoadingSearch ? (
        <div className="text-center py-8">Đang tìm kiếm...</div>
      ) : searchResults.length > 0 ? (
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4">
          {searchResults.map((comic, index) => (
            <div 
              key={comic.id || index} 
              className="flex flex-col cursor-pointer transition-transform hover:scale-105" 
              onClick={() => handleComicClick(comic.slug)}
            >
              <TiltedCard
                imageSrc={
                  comic.thumbnail ||
                  "https://picsum.photos/seed/placeholder/800/600"
                }
                altText={comic.title || "Comic image"}
                captionText=""
                containerHeight="240px"
                containerWidth="100%"
                imageHeight="240px"
                imageWidth="160px"
                scaleOnHover={1.1}
                rotateAmplitude={14}
                showMobileWarning={true}
                showTooltip={true}
                overlayContent={
                  <div className="text-white text-xs p-1 bg-black bg-opacity-70">
                    {getTimeAgo(comic.updatedAt || new Date().toISOString())}
                  </div>
                }
                displayOverlayContent={true}
              />
              <div className="mt-2">
                <h3 className="font-semibold text-sm truncate text-gray-800 dark:text-gray-100">
                  {comic.title}
                </h3>
                <div className="flex items-center mt-1 justify-center">
                  <BookOpen
                    size={14}
                    className="text-blue-600 dark:text-blue-400 mr-1 transition-colors duration-200"
                  />
                  <p className="text-xs font-medium text-gray-700 dark:text-gray-300 transition-colors duration-200">
                    Chap {comic.latestChapter?.chapterName || "Chưa có chapter"}
                  </p>
                </div>
              </div>
            </div>
          ))}
        </div>
      ) : keyword ? (
        <div className="text-center py-8 dark:text-white">
          Không tìm thấy kết quả cho "{keyword}"
        </div>
      ) : (
        <div className="text-center py-8 dark:text-white">
          Nhập từ khóa để tìm truyện
        </div>
      )}

      {searchResults.length > 0 && renderPagination()}
    </div>
  );
};

export default SearchPage;
</file>

<file path="src/store/comicStore.ts">
import { create } from 'zustand';
import comicApi from '../apis/comic.api';
import { Comic, ComicCarousel, ChapterDetail } from '../types/Comic.type';

interface ComicState {
  // Home comics
  homeComics: ComicCarousel[];
  isLoadingHomeComics: boolean;
  
  // Genre comics
  genreComics: ComicCarousel[];
  currentGenre: string | null;
  currentPage: number;
  isLoadingGenreComics: boolean;
  
  // Search results
  searchResults: ComicCarousel[];
  isLoadingSearch: boolean;
  currentSearchKeyword: string | null;
  currentSearchPage: number;
  
  // Comic detail
  currentComic: Comic | null;
  isLoadingComicDetail: boolean;
  
  // Chapter detail
  currentChapter: ChapterDetail | null;
  isLoadingChapter: boolean;
  
  // Error states
  error: string | null;
  
  // Actions
  fetchHomeComics: () => Promise<void>;
  fetchComicsByGenre: (genre: string, page?: number) => Promise<void>;
  fetchComicDetail: (slug: string) => Promise<void>;
  fetchChapterDetail: (chapterUrl: string) => Promise<void>;
  fetchSearchResults: (keyword: string, page?: number) => Promise<void>;
  
  // UI helpers
  resetError: () => void;
  resetState: () => void;
}

const useComicStore = create<ComicState>((set) => ({
  // Initial state
  homeComics: [],
  isLoadingHomeComics: false,
  
  genreComics: [],
  currentGenre: null,
  currentPage: 1,
  isLoadingGenreComics: false,
  
  searchResults: [],
  isLoadingSearch: false,
  currentSearchKeyword: null,
  currentSearchPage: 1,
  
  currentComic: null,
  isLoadingComicDetail: false,
  
  currentChapter: null,
  isLoadingChapter: false,
  
  error: null,
  
  // Actions
  fetchHomeComics: async () => {
    try {
      set({ isLoadingHomeComics: true, error: null });
      const comics = await comicApi.getHome();
      set({ homeComics: comics, isLoadingHomeComics: false });
    } catch (error) {
      set({ 
        isLoadingHomeComics: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch home comics' 
      });
    }
  },
  
  fetchComicsByGenre: async (genre: string, page: number = 1) => {
    try {
      set({ isLoadingGenreComics: true, error: null });
      const comics = await comicApi.getByGenre(genre, page);
      set({ 
        genreComics: comics, 
        isLoadingGenreComics: false,
        currentGenre: genre,
        currentPage: page
      });
    } catch (error) {
      set({ 
        isLoadingGenreComics: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch comics by genre' 
      });
    }
  },
  
  fetchComicDetail: async (slug: string) => {
    try {
      set({ isLoadingComicDetail: true, error: null });
      const comic = await comicApi.getDetail(slug);
      set({ currentComic: comic, isLoadingComicDetail: false });
    } catch (error) {
      set({ 
        isLoadingComicDetail: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch comic details' 
      });
    }
  },
  
  fetchChapterDetail: async (chapterUrl: string) => {
    try {
      set({ isLoadingChapter: true, error: null });
      const chapter = await comicApi.getChapterDetail(chapterUrl);
      set({ currentChapter: chapter, isLoadingChapter: false });
    } catch (error) {
      set({ 
        isLoadingChapter: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch chapter details' 
      });
    }
  },
  
  fetchSearchResults: async (keyword: string, page: number = 1) => {
    try {
      set({ isLoadingSearch: true, error: null });
      const comics = await comicApi.search(keyword, page);
      set({ 
        searchResults: comics, 
        isLoadingSearch: false,
        currentSearchKeyword: keyword,
        currentSearchPage: page
      });
    } catch (error) {
      set({ 
        isLoadingSearch: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch search results' 
      });
    }
  },
  
  // UI helpers
  resetError: () => set({ error: null }),
  
  resetState: () => set({
    homeComics: [],
    genreComics: [],
    currentGenre: null,
    currentPage: 1,
    searchResults: [],
    currentSearchKeyword: null,
    currentSearchPage: 1,
    currentComic: null,
    currentChapter: null,
    error: null
  })
}));

export default useComicStore;
</file>

</files>
